---
phase: 08-notification-system
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/notification/preferences.py
  - tests/test_notification_preferences.py
  - src/notification/schema.sql
autonomous: true

must_haves:
  truths:
    - "User can enable/disable notifications per event type per thread"
    - "Preferences persist across daemon restarts"
    - "Default preferences allow URGENT and IMPORTANT, block INFORMATIONAL"
    - "Preference changes take effect immediately"
  artifacts:
    - path: "src/notification/preferences.py"
      provides: "Per-thread notification preference storage and matching"
      exports: ["NotificationPreferences"]
      min_lines: 80
    - path: "src/notification/schema.sql"
      provides: "SQLite schema for notification preferences"
      contains: "CREATE TABLE notification_preferences"
    - path: "tests/test_notification_preferences.py"
      provides: "TDD tests for preference CRUD and matching"
      contains: "test.*preference"
  key_links:
    - from: "NotificationPreferences"
      to: "SQLite database"
      via: "Async CRUD operations"
      pattern: "async def (get|set|should_notify)"
    - from: "should_notify()"
      to: "UrgencyLevel"
      via: "Preference matching algorithm"
      pattern: "def should_notify.*UrgencyLevel.*->.*bool"
---

<objective>
Implement per-thread notification preference storage with preference matching algorithm.

Purpose: Enable user control over which notifications they receive per project thread
Output: NotificationPreferences component with SQLite persistence and full TDD coverage
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Phase 2 patterns to follow:
- SQLite with WAL mode for concurrent access safety
- Async aiosqlite for database operations
- Schema in separate .sql file
- initialize() method for table creation

Phase 4 patterns to follow:
- Thread-specific settings storage
- Application Support directory for database location

Event types and default preferences:
- error → enabled (URGENT, critical issues)
- approval_needed → enabled (URGENT, user action required)
- completion → enabled (IMPORTANT, useful feedback)
- progress → disabled (INFORMATIONAL, chatty)
- reconnection → enabled (IMPORTANT, connection awareness)

Default behavior:
- URGENT: always notify (can't be disabled)
- IMPORTANT: enabled by default
- INFORMATIONAL: disabled by default
- SILENT: never notify (can't be enabled)

Existing infrastructure:
@src/session/manager.py - SQLite pattern reference
@src/thread/mapper.py - Thread-specific storage pattern

</context>

<feature>
  <name>Notification Preferences Storage</name>
  <files>src/notification/preferences.py, src/notification/schema.sql, tests/test_notification_preferences.py</files>
  <behavior>
    NotificationPreferences manages per-thread notification settings:

    Schema:
    ```sql
    CREATE TABLE notification_preferences (
      thread_id TEXT NOT NULL,
      event_type TEXT NOT NULL,
      enabled INTEGER NOT NULL DEFAULT 1,
      updated_at TEXT NOT NULL,
      PRIMARY KEY (thread_id, event_type)
    );
    ```

    API:
    - get_preference(thread_id, event_type) → bool (enabled)
    - set_preference(thread_id, event_type, enabled) → None
    - get_all_preferences(thread_id) → dict[event_type, enabled]
    - should_notify(thread_id, event_type, urgency_level) → bool

    should_notify() algorithm:
    1. If urgency is URGENT → always True (override preferences)
    2. If urgency is SILENT → always False (override preferences)
    3. If no preference stored → use default (IMPORTANT=True, INFORMATIONAL=False)
    4. Return stored preference value

    Edge cases:
    - Missing thread_id → use default preferences
    - Unknown event_type → use default for urgency level
    - NULL/invalid values → defensive defaults
  </behavior>
  <implementation>
    TDD approach:
    RED: Write failing tests for CRUD operations and should_notify() logic
    GREEN: Implement async SQLite operations with aiosqlite
    REFACTOR: Extract default preference logic to constant

    Implementation notes:
    - Follow SessionManager pattern: async initialize(), WAL mode
    - Database location: ~/Library/Application Support/claude-signal-daemon/notification_prefs.db
    - UTC timestamps with datetime.now(UTC)
    - Default preferences as class constant: DEFAULT_PREFERENCES
    - Idempotent set_preference (upsert with ON CONFLICT)
    - should_notify() prioritizes urgency rules over user preferences
  </implementation>
</feature>

<verification>
Before declaring plan complete:
- [ ] pytest tests/test_notification_preferences.py passes
- [ ] Test coverage >90% for NotificationPreferences
- [ ] Schema creates table successfully
- [ ] CRUD operations work with SQLite
- [ ] should_notify() respects urgency priority rules
- [ ] Concurrent access safe (WAL mode)
</verification>

<success_criteria>
- Failing test written and committed (RED phase)
- Implementation passes test (GREEN phase)
- Refactor complete if needed
- All 2-3 commits present (test → feat → optional refactor)
- Preference storage persists across restarts
- Urgency rules override user preferences correctly
</success_criteria>

<output>
After completion, create `.planning/phases/08-notification-system/08-02-SUMMARY.md` with:
- RED: Tests written for preference CRUD and matching, why they failed
- GREEN: Implementation that made tests pass
- REFACTOR: Cleanup performed (if any)
- Commits: List of TDD commits produced
</output>
