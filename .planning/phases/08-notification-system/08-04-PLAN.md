---
phase: 08-notification-system
plan: 04
type: execute
wave: 3
depends_on: ["08-01", "08-02", "08-03"]
files_modified:
  - src/notification/manager.py
  - tests/test_notification_manager.py
  - src/claude/orchestrator.py
  - src/approval/workflow.py
  - src/daemon/service.py
  - tests/test_daemon.py
autonomous: true

must_haves:
  truths:
    - "Error events trigger notifications automatically"
    - "Approval events trigger notifications automatically"
    - "Completion events trigger notifications based on preferences"
    - "Notifications respect per-thread preferences"
    - "Notification system initializes on daemon startup"
  artifacts:
    - path: "src/notification/manager.py"
      provides: "NotificationManager orchestrating categorization, preferences, and delivery"
      exports: ["NotificationManager"]
      min_lines: 50
    - path: "tests/test_notification_manager.py"
      provides: "Integration tests for notification flow"
      contains: "test.*notify"
  key_links:
    - from: "NotificationManager.notify()"
      to: "EventCategorizer + NotificationPreferences"
      via: "Event classification and preference check"
      pattern: "categorizer\\.categorize.*preferences\\.should_notify"
    - from: "ClaudeOrchestrator"
      to: "NotificationManager"
      via: "Send error and completion events"
      pattern: "notification_manager\\.notify"
    - from: "ApprovalWorkflow"
      to: "NotificationManager"
      via: "Send approval_needed events"
      pattern: "notification_manager\\.notify"
---

<objective>
Integrate notification system with orchestrator, approval workflow, and daemon for end-to-end notification delivery.

Purpose: Wire notification components into existing event sources and daemon lifecycle
Output: Fully functional notification system integrated throughout codebase
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-notification-system/08-01-SUMMARY.md
@.planning/phases/08-notification-system/08-02-SUMMARY.md
@.planning/phases/08-notification-system/08-03-SUMMARY.md

Event sources to integrate:
@src/claude/orchestrator.py - Error and completion events
@src/approval/workflow.py - approval_needed events
@src/signal/reconnection.py - Reconnection events (Phase 7)

Daemon lifecycle pattern (from Phase 4-5):
@src/daemon/service.py - Component initialization in __init__ and run()

Integration points:
- ClaudeOrchestrator: error handling, task completion
- ApprovalWorkflow: when approval requested
- ReconnectionManager: on reconnection success
- SignalClient: send_message() for delivery

</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NotificationManager orchestration layer</name>
  <files>src/notification/manager.py, tests/test_notification_manager.py</files>
  <action>
    Implement NotificationManager as orchestration layer:

    ```python
    class NotificationManager:
        def __init__(
            self,
            categorizer: EventCategorizer,
            preferences: NotificationPreferences,
            signal_client: SignalClient,
            authorized_number: str
        ):
            self.categorizer = categorizer
            self.preferences = preferences
            self.signal_client = signal_client
            self.authorized_number = authorized_number
            self.formatter = NotificationFormatter()

        async def notify(
            self,
            event_type: str,
            details: dict,
            thread_id: str,
            session_id: str | None = None
        ) -> bool:
            """
            Send notification if event meets criteria.
            Returns True if notification sent, False if skipped.
            """
            # 1. Categorize event
            urgency = self.categorizer.categorize({"type": event_type, "details": details})

            # 2. Check preferences
            if not await self.preferences.should_notify(thread_id, event_type, urgency):
                return False

            # 3. Format message
            event = {
                "type": event_type,
                "details": details,
                "session_id": session_id
            }
            message = self.formatter.format(event, urgency)

            # 4. Send via Signal
            await self.signal_client.send_message(self.authorized_number, message)
            return True
    ```

    Tests to write:
    - test_notify_sends_message_for_urgent_events
    - test_notify_respects_user_preferences
    - test_notify_skips_when_preference_disabled
    - test_notify_formats_message_correctly
    - test_notify_returns_true_when_sent_false_when_skipped
  </action>
  <verify>pytest tests/test_notification_manager.py passes</verify>
  <done>NotificationManager orchestrates categorization, preferences, formatting, and delivery</done>
</task>

<task type="auto">
  <name>Task 2: Wire NotificationManager into ClaudeOrchestrator and ApprovalWorkflow</name>
  <files>src/claude/orchestrator.py, src/approval/workflow.py</files>
  <action>
    Integrate NotificationManager into event sources:

    **ClaudeOrchestrator changes:**
    1. Add notification_manager: NotificationManager | None parameter to __init__
    2. On error in stream handling:
       ```python
       if self.notification_manager:
           await self.notification_manager.notify(
               event_type="error",
               details={"error": str(error), "context": "claude_stream"},
               thread_id=self.current_thread_id,
               session_id=self.current_session_id
           )
       ```
    3. On task completion:
       ```python
       if self.notification_manager:
           await self.notification_manager.notify(
               event_type="completion",
               details={"session_id": session_id, "status": "complete"},
               thread_id=thread_id,
               session_id=session_id
           )
       ```

    **ApprovalWorkflow changes:**
    1. Add notification_manager: NotificationManager | None parameter to __init__
    2. In request_approval():
       ```python
       if self.notification_manager:
           await self.notification_manager.notify(
               event_type="approval_needed",
               details={
                   "tool": tool_call.tool,
                   "target": tool_call.target,
                   "approval_id": request.id[:8]
               },
               thread_id=thread_id,
               session_id=session_id
           )
       ```

    Follow Phase 5 pattern: optional parameter for backwards compatibility.
  </action>
  <verify>No errors when orchestrator/workflow called without notification_manager</verify>
  <done>Event sources send notifications when NotificationManager available</done>
</task>

<task type="auto">
  <name>Task 3: Initialize NotificationManager in daemon startup</name>
  <files>src/daemon/service.py, tests/test_daemon.py</files>
  <action>
    Initialize notification system in daemon lifecycle following Phase 4-5 pattern:

    **In SignalDaemon.__init__():**
    ```python
    # Notification system (Phase 8)
    self.notification_categorizer = EventCategorizer()
    self.notification_prefs = NotificationPreferences(
        str(self.data_dir / "notification_prefs.db")
    )
    self.notification_manager = NotificationManager(
        categorizer=self.notification_categorizer,
        preferences=self.notification_prefs,
        signal_client=self.client,
        authorized_number=config.authorized_number
    )
    ```

    **In SignalDaemon.run():**
    ```python
    # Initialize notification preferences database
    await self.notification_prefs.initialize()
    logger.info("notification_system_initialized")

    # Wire notification manager into components
    self.orchestrator.notification_manager = self.notification_manager
    self.approval_workflow.notification_manager = self.notification_manager

    # Wire notification commands
    self.session_commands.notification_commands = NotificationCommands(
        self.notification_prefs
    )
    ```

    **Startup logging:**
    ```python
    logger.info(
        "notification_system_ready",
        categorizer_rules=len(EventCategorizer.URGENCY_RULES),
        default_prefs=NotificationPreferences.DEFAULT_PREFERENCES
    )
    ```

    Tests to update:
    - Mock notification components in daemon tests
    - Verify initialization order (prefs.initialize() before wiring)
    - Verify components receive notification_manager
  </action>
  <verify>Daemon starts successfully with notification system initialized</verify>
  <done>Notification system integrated into daemon lifecycle</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] pytest tests/test_notification_manager.py passes
- [ ] pytest tests/test_daemon.py passes (with mocked notifications)
- [ ] Daemon starts without errors
- [ ] Error events trigger notifications
- [ ] Approval events trigger notifications
- [ ] Preferences respected (urgent always sent, info only if enabled)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- NOTF-01 satisfied: Critical events send push notifications
- NOTF-02 partial: Preference infrastructure ready (commands in 08-03)
- NOTF-03 satisfied: Urgency categorization working
- NOTF-04 satisfied: Event type enable/disable working
</success_criteria>

<output>
After completion, create `.planning/phases/08-notification-system/08-04-SUMMARY.md`
</output>
