---
phase: 08-notification-system
plan: 05
type: execute
wave: 4
depends_on: ["08-04"]
files_modified:
  - src/session/manager.py
  - src/signal/client.py
  - tests/test_session_integration.py
autonomous: true

must_haves:
  truths:
    - "User receives catch-up summary when reconnecting after Claude worked offline"
    - "Summary includes activity count and recent operations"
    - "Catch-up summary sent before draining message buffer"
    - "Activity log cleared after catch-up summary sent"
  artifacts:
    - path: "src/session/manager.py"
      provides: "generate_catchup_summary() from activity_log"
      exports: ["generate_catchup_summary"]
      min_lines: 20
    - path: "src/signal/client.py"
      provides: "Reconnection flow with catch-up notification"
      contains: "generate_catchup_summary"
  key_links:
    - from: "SignalClient.auto_reconnect()"
      to: "SessionManager.generate_catchup_summary()"
      via: "After reconnection, before draining buffer"
      pattern: "generate_catchup_summary.*session_id"
    - from: "generate_catchup_summary()"
      to: "session.context['activity_log']"
      via: "Read activity log from session context"
      pattern: "activity_log.*context"
---

<objective>
Implement catch-up summary generation deferred from Phase 7 Plan 5, enabling users to see what Claude did while offline.

Purpose: Complete Phase 7 CONN-05 requirement and close TODO from 07-05
Output: Catch-up summary feature with integration test
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-connection-resilience/07-05-SUMMARY.md
@.planning/phases/08-notification-system/08-04-SUMMARY.md

Deferred work from Phase 7-5:
@src/claude/orchestrator.py:75 - TODO comment documents approach
@src/session/manager.py - track_activity() method exists, activity_log in context
@tests/test_session_integration.py - test_claude_continues_working_during_disconnect verifies activity tracking

Activity log structure (from Phase 7):
```python
{
  "timestamp": "2026-01-28T04:35:00Z",
  "type": "command_executed",
  "details": {"command": "read config.json"}
}
```

Reconnection flow (from Phase 7):
1. SignalClient detects disconnect
2. ReconnectionManager handles backoff and retry
3. On successful reconnect → SYNCING state
4. **NEW: Generate catch-up summary before draining buffer**
5. Send summary notification
6. Drain buffered messages
7. Transition to CONNECTED state

Notification system (from 08-04):
- NotificationManager.notify() for sending catch-up as notification
- event_type="reconnection" with urgency IMPORTANT
- Respects user preferences (can be disabled)

</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement generate_catchup_summary() in SessionManager</name>
  <files>src/session/manager.py</files>
  <action>
    Add generate_catchup_summary() method to SessionManager following TODO from Phase 7-5:

    ```python
    async def generate_catchup_summary(self, session_id: str) -> str:
        """
        Generate plain-English summary of Claude's offline work from activity_log.
        Called after reconnection before draining message buffer.

        Returns summary like:
        "While you were away, Claude completed 5 operations:
        - Read config.json (247 lines)
        - Modified src/main.py (23 lines changed)
        - Ran tests (12 passed)
        - Created docs/README.md (50 lines)
        - Committed changes to git

        Ready to continue!"
        """
        session = await self.get_session(session_id)
        if not session:
            return "Session not found"

        activity_log = session.context.get("activity_log", [])
        if not activity_log:
            return "No activity while disconnected"

        # Format summary
        count = len(activity_log)
        summary_lines = [f"While you were away, Claude completed {count} operation{'s' if count != 1 else ''}:"]

        for activity in activity_log:
            # activity: {"timestamp": str, "type": str, "details": dict}
            activity_type = activity.get("type", "unknown")
            details = activity.get("details", {})

            # Format based on activity type
            if activity_type == "tool_call":
                tool = details.get("tool", "unknown")
                target = details.get("target", "")
                summary_lines.append(f"- {tool} {target}")
            elif activity_type == "command_executed":
                command = details.get("command", "unknown")
                summary_lines.append(f"- Executed: {command}")
            else:
                summary_lines.append(f"- {activity_type}")

        summary_lines.append("\nReady to continue!")

        # Clear activity log after generating summary
        await self.update_context(session_id, {"activity_log": []})

        return "\n".join(summary_lines)
    ```

    Edge cases:
    - Empty activity_log → "No activity while disconnected"
    - Missing session → "Session not found"
    - Unknown activity types → show raw type name
  </action>
  <verify>Method exists and returns formatted summary from activity_log</verify>
  <done>generate_catchup_summary() creates plain-English summary from activity log</done>
</task>

<task type="auto">
  <name>Task 2: Wire catch-up summary into reconnection flow</name>
  <files>src/signal/client.py</files>
  <action>
    Integrate catch-up summary into SignalClient.auto_reconnect() after successful reconnection:

    **In auto_reconnect() method:**
    ```python
    # After successful reconnection (existing SYNCING transition code)
    await self.reconnection_manager.transition(ReconnectionState.SYNCING)

    # NEW: Generate and send catch-up summary
    if hasattr(self, 'session_manager') and hasattr(self, 'notification_manager'):
        active_sessions = await self.session_manager.list_sessions()
        for session in active_sessions:
            if session.status == SessionStatus.ACTIVE:
                # Generate summary
                summary = await self.session_manager.generate_catchup_summary(session.id)

                # Send as notification
                await self.notification_manager.notify(
                    event_type="reconnection",
                    details={"summary": summary, "session_id": session.id[:8]},
                    thread_id=self.current_thread_id,  # TODO: map session to thread
                    session_id=session.id
                )

    # Existing code: Drain message buffer
    buffered = self.message_buffer.drain()
    if buffered:
        await self._send_buffered_messages(buffered)

    # Transition to CONNECTED
    await self.reconnection_manager.transition(ReconnectionState.CONNECTED)
    ```

    **Catch-up summary formatting in NotificationFormatter:**
    Update formatter to handle "reconnection" event type with summary in details.

    Edge cases:
    - No active sessions → skip catch-up
    - session_manager or notification_manager not set → graceful skip
    - Empty summary → still notify user of reconnection
  </action>
  <verify>Catch-up summary sent on reconnection before draining buffer</verify>
  <done>Reconnection flow includes catch-up summary notification</done>
</task>

<task type="auto">
  <name>Task 3: Integration test for offline work catch-up</name>
  <files>tests/test_session_integration.py</files>
  <action>
    Add integration test verifying complete offline → reconnect → catch-up flow:

    ```python
    @pytest.mark.asyncio
    async def test_catchup_summary_after_reconnection(
        session_manager,
        notification_manager,
        signal_client
    ):
        """
        Test complete offline work → reconnection → catch-up summary flow.

        Scenario:
        1. Start session
        2. Track several Claude activities
        3. Simulate reconnection
        4. Verify catch-up summary generated
        5. Verify summary sent as notification
        6. Verify activity log cleared after summary
        """
        # 1. Create session
        session = await session_manager.create_session("/tmp/test-project")

        # 2. Track multiple activities
        activities = [
            ("tool_call", {"tool": "Read", "target": "config.json"}),
            ("tool_call", {"tool": "Edit", "target": "src/main.py"}),
            ("command_executed", {"command": "pytest"}),
        ]
        for activity_type, details in activities:
            await session_manager.track_activity(session.id, activity_type, details)

        # 3. Generate catch-up summary
        summary = await session_manager.generate_catchup_summary(session.id)

        # 4. Verify summary content
        assert "3 operations" in summary
        assert "Read config.json" in summary
        assert "Edit src/main.py" in summary
        assert "pytest" in summary
        assert "Ready to continue" in summary

        # 5. Verify activity log cleared
        updated_session = await session_manager.get_session(session.id)
        assert updated_session.context.get("activity_log") == []
    ```

    Additional test for empty activity log:
    ```python
    @pytest.mark.asyncio
    async def test_catchup_summary_empty_activity_log(session_manager):
        session = await session_manager.create_session("/tmp/test-project")
        summary = await session_manager.generate_catchup_summary(session.id)
        assert summary == "No activity while disconnected"
    ```
  </action>
  <verify>pytest tests/test_session_integration.py::test_catchup_summary_after_reconnection passes</verify>
  <done>Integration test proves catch-up summary works end-to-end</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] pytest tests/test_session_integration.py passes (new tests)
- [ ] generate_catchup_summary() returns formatted summary
- [ ] Catch-up summary sent on reconnection
- [ ] Activity log cleared after summary
- [ ] Summary respects notification preferences
- [ ] TODO comment from 07-05 resolved
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- CONN-05 fully satisfied: User catches up on reconnect
- Phase 7 TODO from orchestrator.py resolved
- Activity tracking → summary → notification flow complete
</success_criteria>

<output>
After completion, create `.planning/phases/08-notification-system/08-05-SUMMARY.md`
</output>
