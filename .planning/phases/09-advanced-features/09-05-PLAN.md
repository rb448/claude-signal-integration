---
phase: 09-advanced-features
plan: 05
type: execute
wave: 3
depends_on: ["09-03", "09-04"]
files_modified:
  - src/daemon/service.py
  - src/session/commands.py
  - tests/test_daemon.py
autonomous: true

must_haves:
  truths:
    - "Custom commands sync on daemon startup"
    - "Emergency mode initializes on daemon startup"
    - "/custom commands route to CustomCommands handler"
    - "/emergency commands route to EmergencyCommands handler"
    - "Priority routing: approval → emergency → notify → custom → thread → session → claude"
  artifacts:
    - path: "src/daemon/service.py"
      provides: "Daemon with custom command and emergency mode initialization"
    - path: "src/session/commands.py"
      provides: "Updated routing to include custom and emergency commands"
  key_links:
    - from: "src/daemon/service.py"
      to: "src/custom_commands/syncer.py"
      via: "initialize syncer on daemon startup"
      pattern: "CommandSyncer|initial_scan"
    - from: "src/daemon/service.py"
      to: "src/emergency/mode.py"
      via: "initialize emergency mode on daemon startup"
      pattern: "EmergencyMode|initialize"
    - from: "src/session/commands.py"
      to: "src/custom_commands/commands.py"
      via: "route /custom messages to handler"
      pattern: "custom_commands\\.handle"
    - from: "src/session/commands.py"
      to: "src/emergency/commands.py"
      via: "route /emergency messages to handler"
      pattern: "emergency_commands\\.handle"
---

<objective>
Wire custom command sync and emergency mode into daemon, integrate command routing.

Purpose: Complete Phase 9 by connecting custom commands and emergency mode to Signal bot daemon.
Output: Daemon initializes custom commands and emergency mode, SessionCommands routes to new handlers.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase patterns
@.planning/phases/04-multi-project/04-03-SUMMARY.md  # Daemon integration pattern
@.planning/phases/05-permissions/05-05-SUMMARY.md  # Daemon approval system wiring
@.planning/phases/08-notification-system/08-04-SUMMARY.md  # Daemon notification wiring
@.planning/phases/09-advanced-features/09-01-SUMMARY.md  # CommandSyncer + Registry
@.planning/phases/09-advanced-features/09-02-SUMMARY.md  # EmergencyMode
@.planning/phases/09-advanced-features/09-03-SUMMARY.md  # CustomCommands
@.planning/phases/09-advanced-features/09-04-SUMMARY.md  # EmergencyCommands

# Key architectural decisions
- Components initialized in daemon run() method (Phases 4, 5, 8)
- async initialize() pattern for components (Phase 4)
- SessionCommands receives components via parameters (Phase 5, 8)
- Priority routing order matters for command disambiguation (Phase 8)
- Startup logging with component metrics (Phases 4, 5)

# Integration requirements
- Initialize CommandSyncer and run initial_scan() on startup
- Initialize EmergencyMode and restore state from database
- Wire CustomCommands and EmergencyCommands into SessionCommands
- Update command routing priority order
- Log startup metrics (custom commands synced, emergency mode state)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize custom commands in daemon startup</name>
  <files>src/daemon/service.py</files>
  <action>
    Update Daemon.run() to initialize custom command infrastructure:

    In __init__:
    - Create CustomCommandRegistry instance
    - Create CommandSyncer instance with registry

    In async run():
    - Call await registry.initialize() (async schema setup)
    - Call await syncer.initial_scan() (load existing commands)
    - Start syncer.observer (file system watcher)
    - Log: f"Custom commands: {len(registry.list_commands())} synced from ~/.claude/agents/"

    On shutdown (in finally block):
    - Call syncer.stop() (stop file system observer)

    Follow Phase 4-3 pattern: components initialized in __init__, async initialize in run().
    Application Support directory path for custom_commands.db.
    Syncer runs in background thread (watchdog Observer pattern).
  </action>
  <verify>Daemon starts, syncs custom commands, logs count</verify>
  <done>Daemon initializes custom command syncing, loads existing commands on startup</done>
</task>

<task type="auto">
  <name>Task 2: Initialize emergency mode in daemon startup</name>
  <files>src/daemon/service.py</files>
  <action>
    Update Daemon.run() to initialize emergency mode:

    In __init__:
    - Create EmergencyMode instance
    - Create EmergencyAutoApprover instance
    - Create EmergencyAutoCommitter instance

    In async run():
    - Call await emergency_mode.initialize() (async schema setup)
    - status = "EMERGENCY" if emergency_mode.is_active() else "NORMAL"
    - Log: f"Emergency mode: {status}"

    Wire emergency components into approval_workflow:
    - Update approval_workflow creation to pass emergency_auto_approver

    Follow Phase 5-5 pattern: emergency components stateless, no complex lifecycle.
    Application Support directory path for emergency_mode.db.
  </action>
  <verify>Daemon starts, initializes emergency mode, logs status</verify>
  <done>Daemon initializes emergency mode, restores state from database</done>
</task>

<task type="auto">
  <name>Task 3: Wire custom and emergency commands into SessionCommands routing</name>
  <files>src/session/commands.py, src/daemon/service.py</files>
  <action>
    Update SessionCommands:
    - Add custom_commands and emergency_commands parameters to __init__
    - Update handle() routing logic:
      ```python
      # Priority order: approval → emergency → notify → custom → thread → code → session → claude
      if message.startswith("/approve") or message.startswith("/reject"):
          return await self.approval_commands.handle(thread_id, message)
      elif message.startswith("/emergency"):
          return await self.emergency_commands.handle(thread_id, message)
      elif message.startswith("/notify"):
          return await self.notification_commands.handle(thread_id, message)
      elif message.startswith("/custom"):
          return await self.custom_commands.handle(thread_id, message)
      elif message.startswith("/thread"):
          return await self.thread_commands.handle(thread_id, message)
      # ... existing /code, /session routing
      ```

    Update Daemon.run():
    - Create CustomCommands(registry, orchestrator)
    - Create EmergencyCommands(emergency_mode)
    - Pass to SessionCommands via parameters

    Follow Phase 8-3 priority routing pattern.
    Emergency comes before custom (urgent operations first).
    Custom comes before thread/session (feature-specific before generic).
  </action>
  <verify>SessionCommands routes /custom and /emergency to correct handlers</verify>
  <done>SessionCommands routes custom and emergency commands, priority order updated</done>
</task>

<task type="auto">
  <name>Task 4: Integration test for daemon startup with new components</name>
  <files>tests/test_daemon_advanced_features.py</files>
  <action>
    Write integration test verifying daemon startup with custom commands and emergency mode:
    - Mock signal_client, create temp directories for databases
    - Start daemon
    - Verify:
      1. CustomCommandRegistry initialized and commands synced
      2. CommandSyncer initial_scan() ran
      3. EmergencyMode initialized and state loaded
      4. Startup logs include custom command count and emergency status
      5. SessionCommands has custom_commands and emergency_commands wired
      6. Routing works: /custom list → CustomCommands, /emergency status → EmergencyCommands

    Test lifecycle:
    - Create test command file in ~/.claude/agents/ (temp directory)
    - Start daemon
    - Verify command synced to registry
    - Stop daemon (syncer.stop() called)

    Use tempfile.TemporaryDirectory for test isolation.
    Mock SignalClient to avoid actual Signal API calls.
  </action>
  <verify>pytest tests/test_daemon_advanced_features.py -v passes</verify>
  <done>Daemon integration test verifies custom commands and emergency mode initialization</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] pytest tests/test_daemon_advanced_features.py -v passes
- [ ] Daemon logs custom command count on startup
- [ ] Daemon logs emergency mode status on startup
- [ ] /custom commands route to CustomCommands handler
- [ ] /emergency commands route to EmergencyCommands handler
- [ ] Priority routing order: approval → emergency → notify → custom → thread → code → session → claude
- [ ] CommandSyncer starts file system watcher
- [ ] EmergencyMode restores state from database
</verification>

<success_criteria>

- All integration tests pass
- Daemon initializes custom command syncing and emergency mode
- SessionCommands routes to CustomCommands and EmergencyCommands
- Command routing priority order correct
- Startup logging shows component status
- Code follows Phase 4/5/8 patterns (daemon lifecycle, component wiring, priority routing)
- No new test failures or skipped tests introduced
</success_criteria>

<output>
After completion, create `.planning/phases/09-advanced-features/09-05-SUMMARY.md`
</output>
