---
phase: 09-advanced-features
plan: 04
type: execute
wave: 2
depends_on: ["09-02"]
files_modified:
  - src/emergency/commands.py
  - tests/test_emergency_commands.py
  - src/approval/workflow.py
  - tests/test_approval_workflow.py
autonomous: true

must_haves:
  truths:
    - "User can activate emergency mode from Signal"
    - "User can deactivate emergency mode from Signal"
    - "User can check emergency mode status"
    - "Emergency mode overrides approval workflow for SAFE tools"
    - "Emergency mode still requires approval for DESTRUCTIVE tools"
  artifacts:
    - path: "src/emergency/commands.py"
      provides: "/emergency command handler (activate, deactivate, status)"
      exports: ["EmergencyCommands"]
      min_lines: 50
    - path: "tests/test_emergency_commands.py"
      provides: "TDD tests for emergency command interface"
      min_lines: 60
    - path: "src/approval/workflow.py"
      provides: "Updated to integrate emergency auto-approval"
  key_links:
    - from: "src/emergency/commands.py"
      to: "src/emergency/mode.py"
      via: "activate/deactivate emergency state"
      pattern: "emergency_mode\\.activate|emergency_mode\\.deactivate"
    - from: "src/approval/workflow.py"
      to: "src/emergency/auto_approver.py"
      via: "check auto-approval before creating approval request"
      pattern: "auto_approver\\.should_auto_approve"
---

<objective>
Build emergency mode command interface and integrate with approval workflow for auto-approval of safe operations.

Purpose: Enable users to activate/deactivate emergency mode and override approval checks for safe operations.
Output: EmergencyCommands handler, ApprovalWorkflow integration with emergency auto-approval.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase patterns
@.planning/phases/05-permissions/05-04-SUMMARY.md  # ApprovalCommands pattern
@.planning/phases/05-permissions/05-02-SUMMARY.md  # ApprovalWorkflow request creation
@.planning/phases/09-advanced-features/09-02-SUMMARY.md  # EmergencyMode, EmergencyAutoApprover

# Key architectural decisions
- Follow ApprovalCommands pattern for command handlers (Phase 5)
- async handle(thread_id, message) signature (Phase 4)
- Priority routing: approval → emergency → notify → thread → session (Phase 8)
- Mobile-friendly emoji status indicators (Phase 8)
- ApprovalWorkflow.request_approval() integration point (Phase 5)

# Emergency mode requirements
- /emergency activate → activates emergency mode for thread
- /emergency deactivate → deactivates emergency mode
- /emergency status → shows current mode (NORMAL or EMERGENCY)
- ApprovalWorkflow checks emergency mode before creating approval request
- Auto-approve SAFE tools (Read, Grep, Glob) in emergency mode
- Still require approval for DESTRUCTIVE tools (Edit, Write, Bash)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EmergencyCommands handler with TDD</name>
  <files>tests/test_emergency_commands.py, src/emergency/commands.py</files>
  <action>
    RED: Write failing tests for EmergencyCommands:
    - test_handle_activate() → "/emergency activate" activates mode, returns confirmation
    - test_handle_deactivate() → "/emergency deactivate" deactivates mode, returns confirmation
    - test_handle_status_active() → "/emergency status" returns "EMERGENCY (activated ...)"
    - test_handle_status_normal() → "/emergency status" returns "NORMAL"
    - test_handle_help() → "/emergency help" returns usage instructions
    - test_unknown_subcommand() → "/emergency unknown" returns help text
    - test_activate_records_thread() → activation records which thread activated it

    GREEN: Implement EmergencyCommands:
    - __init__(self, emergency_mode: EmergencyMode)
    - async handle(self, thread_id: str, message: str) → str
    - Parse subcommands: activate, deactivate, status, help
    - activate(thread_id) → emergency_mode.activate(thread_id) → "⚡ Emergency mode ACTIVATED"
    - deactivate() → emergency_mode.deactivate() → "✅ Emergency mode deactivated"
    - status() → emergency_mode.is_active() → format status with emoji (⚡ EMERGENCY or ✅ NORMAL)
    - help() → return usage text with examples
    - Include warning in activate message: "Safe ops auto-approved, destructive still need approval"

    REFACTOR: Extract formatting helpers if needed.

    Follow ApprovalCommands pattern from Phase 5 (async handle, subcommand routing).
    Emoji for status: ⚡ for emergency, ✅ for normal (Phase 8 pattern).
    Include timestamp in status message (when activated, Phase 9-02).
  </action>
  <verify>pytest tests/test_emergency_commands.py -v passes all tests</verify>
  <done>EmergencyCommands handles /emergency activate/deactivate/status, formats for mobile</done>
</task>

<task type="auto">
  <name>Task 2: Integrate emergency auto-approval into ApprovalWorkflow</name>
  <files>src/approval/workflow.py, tests/test_approval_workflow.py</files>
  <action>
    Update ApprovalWorkflow.request_approval() to check emergency mode:
    - Add emergency_auto_approver parameter to __init__
    - In request_approval(tool_call, ...):
      1. Check: if auto_approver.should_auto_approve(tool_name, emergency_mode) → return immediately (no approval needed)
      2. Otherwise: proceed with normal approval flow (create request, notify user)

    Update tests:
    - test_auto_approve_read_in_emergency() → Read tool auto-approved, no request created
    - test_auto_approve_grep_in_emergency() → Grep tool auto-approved
    - test_require_approval_edit_in_emergency() → Edit tool still requires approval
    - test_normal_mode_flow_unchanged() → emergency mode doesn't affect normal mode

    Integration point: Before creating ApprovalRequest, check emergency auto-approval.
    If auto-approved, skip request creation and return immediately.
    Existing approval logic unchanged for non-auto-approved tools.
  </action>
  <verify>pytest tests/test_approval_workflow.py -v passes with new emergency tests</verify>
  <done>ApprovalWorkflow auto-approves SAFE tools in emergency mode, normal flow for DESTRUCTIVE</done>
</task>

<task type="auto">
  <name>Task 3: Integration test for emergency approval override</name>
  <files>tests/test_emergency_approval_integration.py</files>
  <action>
    Write integration test verifying emergency mode approval override:
    - Setup: EmergencyMode, EmergencyAutoApprover, ApprovalWorkflow
    - Test scenario:
      1. Normal mode: Read tool → approval request created
      2. Activate emergency mode
      3. Read tool → auto-approved, no request created
      4. Edit tool → approval request created (still requires approval)
      5. Deactivate emergency mode
      6. Read tool → approval request created (back to normal)

    Verify auto-approval only applies when:
    - Emergency mode is active
    - Tool is classified as SAFE
    - Both conditions must be true

    Use real EmergencyMode, ApprovalWorkflow instances (not mocked).
    Verify request_manager.list_pending() for approval request counts.
  </action>
  <verify>pytest tests/test_emergency_approval_integration.py -v passes</verify>
  <done>Emergency mode correctly overrides approval for SAFE tools, preserves approval for DESTRUCTIVE</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] pytest tests/test_emergency_commands.py -v passes
- [ ] pytest tests/test_approval_workflow.py -v passes (with emergency tests)
- [ ] pytest tests/test_emergency_approval_integration.py -v passes
- [ ] /emergency activate enables auto-approval for SAFE tools
- [ ] /emergency deactivate restores normal approval flow
- [ ] /emergency status shows current mode with timestamp
- [ ] DESTRUCTIVE tools still require approval in emergency mode
</verification>

<success_criteria>

- All TDD tests pass (RED-GREEN-REFACTOR cycle followed)
- EmergencyCommands handles activate/deactivate/status subcommands
- ApprovalWorkflow integrates emergency auto-approval
- Integration test verifies auto-approval override works correctly
- Code follows Phase 5/8 patterns (approval workflow, command handler, emoji status)
- No new test failures or skipped tests introduced
</success_criteria>

<output>
After completion, create `.planning/phases/09-advanced-features/09-04-SUMMARY.md`
</output>
