---
phase: 09-advanced-features
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/emergency/__init__.py
  - src/emergency/mode.py
  - src/emergency/auto_approver.py
  - src/emergency/auto_committer.py
  - tests/test_emergency_mode.py
  - tests/test_emergency_auto_approver.py
  - tests/test_emergency_auto_committer.py
autonomous: true

must_haves:
  truths:
    - "User can activate emergency mode"
    - "Emergency mode auto-approves safe operations (Read, Grep, Glob)"
    - "Emergency mode requires manual approval for destructive operations (Edit, Write, Bash)"
    - "Emergency mode auto-commits successful changes"
    - "User can deactivate emergency mode"
    - "Emergency mode state persists across daemon restarts"
  artifacts:
    - path: "src/emergency/mode.py"
      provides: "Emergency mode state machine with activate/deactivate"
      exports: ["EmergencyMode", "EmergencyStatus"]
      min_lines: 50
    - path: "src/emergency/auto_approver.py"
      provides: "Auto-approval rules for emergency mode"
      exports: ["EmergencyAutoApprover"]
      min_lines: 30
    - path: "src/emergency/auto_committer.py"
      provides: "Auto-commit formatter for emergency changes"
      exports: ["EmergencyAutoCommitter"]
      min_lines: 40
    - path: "tests/test_emergency_mode.py"
      provides: "TDD tests for emergency mode state machine"
      min_lines: 60
  key_links:
    - from: "src/emergency/mode.py"
      to: "emergency_mode.db"
      via: "SQLite persistence for mode state"
      pattern: "CREATE TABLE|INSERT|UPDATE"
    - from: "src/emergency/auto_approver.py"
      to: "src/approval/workflow.py"
      via: "override approval checks in emergency mode"
      pattern: "ToolClassification|SAFE|DESTRUCTIVE"
    - from: "src/emergency/auto_committer.py"
      to: "git commands"
      via: "auto-commit after successful operations"
      pattern: "git add|git commit"
---

<objective>
Build emergency mode state machine with auto-approval and auto-commit capabilities for production incident response.

Purpose: Enable streamlined emergency workflows where safe operations auto-approve and successful changes auto-commit.
Output: EmergencyMode state machine, EmergencyAutoApprover rules, EmergencyAutoCommitter formatter.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase patterns
@.planning/phases/02-session-management/02-02-SUMMARY.md  # State machine with VALID_TRANSITIONS
@.planning/phases/05-permissions/05-01-SUMMARY.md  # ToolClassification (SAFE vs DESTRUCTIVE)
@.planning/phases/07-connection-resilience/07-01-SUMMARY.md  # State machine with set-based transitions

# Key architectural decisions
- Set-based VALID_TRANSITIONS for O(1) lookup (Phase 2)
- ToolClassification.SAFE vs DESTRUCTIVE (Phase 5)
- SQLite with WAL mode for persistence (Phase 2)
- UTC-aware timestamps (Phase 2)
- Application Support directory for databases (Phases 2, 4, 8)
- Async initialization pattern (Phase 4)

# Emergency mode requirements from roadmap
- Pre-approves safe operations (Read, Grep, Glob)
- Requires approval for destructive operations (Edit, Write, Bash)
- Auto-commits changes after successful operations
- User can activate/deactivate
- State persists across restarts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EmergencyMode state machine with TDD</name>
  <files>tests/test_emergency_mode.py, src/emergency/__init__.py, src/emergency/mode.py</files>
  <action>
    RED: Write failing tests for EmergencyMode:
    - test_activate() → status transitions NORMAL → EMERGENCY
    - test_deactivate() → status transitions EMERGENCY → NORMAL
    - test_is_active() → returns True when EMERGENCY, False when NORMAL
    - test_persistence() → activate, restart, load → still EMERGENCY
    - test_activated_at_timestamp() → records when emergency mode activated
    - test_activated_by_thread() → tracks which thread activated emergency mode
    - test_idempotent_activate() → activate when EMERGENCY is no-op
    - test_idempotent_deactivate() → deactivate when NORMAL is no-op

    GREEN: Implement EmergencyMode:
    - EmergencyStatus enum: NORMAL = 0, EMERGENCY = 1
    - SQLite database at ~/Library/Application Support/claude-signal-bot/emergency_mode.db
    - Schema: emergency_state(id INTEGER PRIMARY KEY, status INTEGER, activated_at TEXT, activated_by_thread TEXT)
    - Single row (id=1) stores current state
    - WAL mode for concurrent access
    - activate(thread_id: str) → set status=EMERGENCY, record thread and timestamp
    - deactivate() → set status=NORMAL, clear thread
    - is_active() → query status from database
    - Async initialize() method for schema setup
    - UTC-aware timestamps

    REFACTOR: Clean up if needed.

    Follow Phase 2 state machine pattern with set-based transitions.
    Single-row state storage pattern (id=1 always exists, UPDATE only).
  </action>
  <verify>pytest tests/test_emergency_mode.py -v passes all tests</verify>
  <done>EmergencyMode state machine transitions between NORMAL and EMERGENCY, persists to SQLite</done>
</task>

<task type="auto">
  <name>Task 2: Create EmergencyAutoApprover with TDD</name>
  <files>tests/test_emergency_auto_approver.py, src/emergency/auto_approver.py</files>
  <action>
    RED: Write failing tests for EmergencyAutoApprover:
    - test_auto_approve_read() → Read tool auto-approved in emergency mode
    - test_auto_approve_grep() → Grep tool auto-approved
    - test_auto_approve_glob() → Glob tool auto-approved
    - test_require_approval_edit() → Edit tool requires approval even in emergency
    - test_require_approval_write() → Write tool requires approval
    - test_require_approval_bash() → Bash tool requires approval
    - test_not_emergency_mode() → all tools follow normal approval rules when mode=NORMAL

    GREEN: Implement EmergencyAutoApprover:
    - should_auto_approve(tool_name: str, emergency_mode: EmergencyMode) → bool
    - If emergency_mode.is_active() is False → return False (normal approval flow)
    - If emergency_mode.is_active() is True:
      - SAFE tools (Read, Grep, Glob) → return True (auto-approve)
      - DESTRUCTIVE tools (Edit, Write, Bash) → return False (require approval)
    - Use ToolClassification from Phase 5 for consistency

    REFACTOR: None needed (simple logic).

    Reuse ToolClassification.SAFE from src/approval/classifier.py (Phase 5).
    Auto-approval only applies to SAFE tools, destructive still need explicit approval.
  </action>
  <verify>pytest tests/test_emergency_auto_approver.py -v passes all tests</verify>
  <done>EmergencyAutoApprover auto-approves SAFE tools in emergency mode, requires approval for DESTRUCTIVE</done>
</task>

<task type="auto">
  <name>Task 3: Create EmergencyAutoCommitter with TDD</name>
  <files>tests/test_emergency_auto_committer.py, src/emergency/auto_committer.py</files>
  <action>
    RED: Write failing tests for EmergencyAutoCommitter:
    - test_format_commit_message() → generates message with [EMERGENCY] prefix
    - test_includes_session_id() → commit message includes session for traceability
    - test_includes_operation_summary() → describes what changed (file edits, writes)
    - test_commit_after_successful_edit() → auto-commits after Edit tool succeeds
    - test_commit_after_successful_write() → auto-commits after Write tool succeeds
    - test_no_commit_on_failure() → does not commit if operation failed
    - test_no_commit_in_normal_mode() → auto-commit only happens in emergency mode

    GREEN: Implement EmergencyAutoCommitter:
    - format_commit_message(session_id: str, operation: str, files: list[str]) → str
    - Message format: "[EMERGENCY] {operation}: {files} (session: {session_id[:8]})"
    - auto_commit(session_id: str, project_path: str, operation: str, files: list[str]) → None
    - Runs git commands: git add {files}, git commit -m {message}
    - Only commits if emergency_mode.is_active() is True
    - Only commits after successful operation (no errors reported)

    REFACTOR: Extract git command execution if needed.

    Follow Phase 2 patterns for subprocess execution (asyncio.create_subprocess_exec).
    Commit message includes session ID (truncated to 8 chars, Phase 2 pattern).
    Auto-commit runs after Claude operations complete successfully.
  </action>
  <verify>pytest tests/test_emergency_auto_committer.py -v passes all tests</verify>
  <done>EmergencyAutoCommitter generates commit messages and auto-commits successful changes in emergency mode</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] pytest tests/test_emergency_mode.py -v passes
- [ ] pytest tests/test_emergency_auto_approver.py -v passes
- [ ] pytest tests/test_emergency_auto_committer.py -v passes
- [ ] emergency_mode.db created in Application Support directory
- [ ] Emergency mode state persists across restarts
- [ ] Auto-approval only applies to SAFE tools
- [ ] Auto-commit only runs in emergency mode after success
</verification>

<success_criteria>

- All TDD tests pass (RED-GREEN-REFACTOR cycle followed)
- EmergencyMode state machine transitions and persists state
- EmergencyAutoApprover auto-approves SAFE tools, requires approval for DESTRUCTIVE
- EmergencyAutoCommitter formats messages and auto-commits changes
- Code follows Phase 2/5/7 patterns (state machine, tool classification, SQLite)
- No new test failures or skipped tests introduced
</success_criteria>

<output>
After completion, create `.planning/phases/09-advanced-features/09-02-SUMMARY.md`
</output>
