---
phase: 09-advanced-features
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/custom_commands/__init__.py
  - src/custom_commands/syncer.py
  - src/custom_commands/registry.py
  - tests/test_custom_command_syncer.py
  - tests/test_custom_command_registry.py
autonomous: true

must_haves:
  truths:
    - "System detects new custom commands in ~/.claude/agents/"
    - "System detects modified custom commands"
    - "System detects deleted custom commands"
    - "Custom commands are stored in retrievable registry"
    - "Registry persists across daemon restarts"
  artifacts:
    - path: "src/custom_commands/syncer.py"
      provides: "File system watcher for ~/.claude/agents/ directory"
      min_lines: 40
    - path: "src/custom_commands/registry.py"
      provides: "Command storage with CRUD operations"
      exports: ["CustomCommandRegistry"]
    - path: "tests/test_custom_command_syncer.py"
      provides: "TDD tests for command syncing logic"
      min_lines: 50
    - path: "tests/test_custom_command_registry.py"
      provides: "TDD tests for registry operations"
      min_lines: 40
  key_links:
    - from: "src/custom_commands/syncer.py"
      to: "~/.claude/agents/"
      via: "watchdog file system events"
      pattern: "FileSystemEventHandler|Observer"
    - from: "src/custom_commands/syncer.py"
      to: "src/custom_commands/registry.py"
      via: "registry update on file changes"
      pattern: "registry\\.add|registry\\.update|registry\\.remove"
    - from: "src/custom_commands/registry.py"
      to: "custom_commands.db"
      via: "SQLite persistence"
      pattern: "CREATE TABLE|INSERT|UPDATE|DELETE"
---

<objective>
Build custom command synchronization infrastructure that watches ~/.claude/agents/ and maintains a persistent registry.

Purpose: Enable mobile access to user's local custom Claude Code commands by detecting changes and storing metadata.
Output: CommandSyncer monitors file system, CustomCommandRegistry provides CRUD with SQLite persistence.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase patterns
@.planning/phases/04-multi-project/04-01-SUMMARY.md  # ThreadMapper SQLite persistence pattern
@.planning/phases/02-session-management/02-01-SUMMARY.md  # SessionManager SQLite with WAL mode

# Key architectural decisions from STATE.md
- SQLite with WAL mode for concurrent access (Phase 2)
- UTC-aware datetime.now(UTC) for timestamps (Phase 2)
- Idempotent operations for safe retry logic (Phase 2, 4)
- Application Support directory for databases (Phases 2, 4, 8)
- Async initialization pattern (Phase 4)

# Custom command requirements
- ~/.claude/agents/ contains user's custom Claude Code commands (*.md files)
- Each command file has frontmatter with name, description, parameters
- Commands can be added/modified/deleted while daemon running
- Need real-time detection for responsive mobile UX
- Registry must survive daemon restarts (persistent storage)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CustomCommandRegistry with TDD</name>
  <files>tests/test_custom_command_registry.py, src/custom_commands/__init__.py, src/custom_commands/registry.py</files>
  <action>
    RED: Write failing tests for CustomCommandRegistry:
    - test_add_command(name, path, metadata) → command stored
    - test_get_command(name) → returns command or None
    - test_list_commands() → returns all commands
    - test_update_command(name, new_metadata) → metadata updated
    - test_remove_command(name) → command removed
    - test_command_exists(name) → boolean check
    - test_persistence() → save, restart, load → commands persist

    GREEN: Implement CustomCommandRegistry:
    - SQLite database at ~/Library/Application Support/claude-signal-bot/custom_commands.db
    - Schema: commands(name TEXT PRIMARY KEY, file_path TEXT, metadata JSON, updated_at TEXT)
    - WAL mode for concurrent access (follows Phase 2 pattern)
    - Async initialize() method for schema setup
    - UTC-aware timestamps with datetime.now(UTC)
    - Idempotent operations (add/update/remove don't error if state already matches)

    REFACTOR: Extract SQL queries to constants if needed for clarity.

    Follow Phase 4 ThreadMapper pattern: class initialized sync, async initialize() called in async context.
    Use JSON blob for metadata (flexible structure, no schema migrations needed - Phase 2 pattern).
  </action>
  <verify>pytest tests/test_custom_command_registry.py -v passes all tests</verify>
  <done>CustomCommandRegistry stores/retrieves/updates/removes commands, persists to SQLite with WAL mode</done>
</task>

<task type="auto">
  <name>Task 2: Create CommandSyncer with TDD</name>
  <files>tests/test_custom_command_syncer.py, src/custom_commands/syncer.py</files>
  <action>
    RED: Write failing tests for CommandSyncer:
    - test_detect_new_command() → file created → syncer.add() called with parsed metadata
    - test_detect_modified_command() → file modified → syncer.update() called
    - test_detect_deleted_command() → file deleted → syncer.remove() called
    - test_parse_command_frontmatter() → extract name, description from .md file
    - test_ignore_non_md_files() → .txt, .py files ignored
    - test_initial_scan() → existing commands loaded on startup

    GREEN: Implement CommandSyncer:
    - Use watchdog library for file system monitoring (FileSystemEventHandler)
    - Monitor ~/.claude/agents/ directory (create if doesn't exist)
    - Parse .md files for frontmatter (name, description, parameters)
    - On file created: parse → registry.add()
    - On file modified: parse → registry.update()
    - On file deleted: registry.remove()
    - initial_scan() method: walk directory, add all existing commands
    - Ignore non-.md files
    - Handle parse errors gracefully (log warning, skip file)

    REFACTOR: Extract frontmatter parsing to separate function if complex.

    Use python-frontmatter library for parsing .md files (standard choice for frontmatter).
    Observer pattern from watchdog: create observer, schedule handler, start in separate thread.
  </action>
  <verify>pytest tests/test_custom_command_syncer.py -v passes all tests</verify>
  <done>CommandSyncer detects file changes in ~/.claude/agents/, updates registry with parsed metadata</done>
</task>

<task type="auto">
  <name>Task 3: Integration test for syncer + registry</name>
  <files>tests/test_custom_command_integration.py</files>
  <action>
    Write integration test verifying end-to-end flow:
    - Create temp directory simulating ~/.claude/agents/
    - Initialize registry with temp database
    - Create syncer pointing to temp directory
    - Test scenario:
      1. Create test.md with frontmatter → verify registry.get("test") returns metadata
      2. Modify test.md frontmatter → verify registry reflects updated metadata
      3. Delete test.md → verify registry.get("test") returns None
    - Test initial scan: directory with 3 .md files → syncer.initial_scan() → registry has 3 commands

    Use tempfile.TemporaryDirectory for test isolation.
    Use time.sleep(0.1) after file operations to allow watchdog to process events.
  </action>
  <verify>pytest tests/test_custom_command_integration.py -v passes</verify>
  <done>Syncer + registry work together: file changes update registry in real-time</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] pytest tests/test_custom_command_registry.py -v passes
- [ ] pytest tests/test_custom_command_syncer.py -v passes
- [ ] pytest tests/test_custom_command_integration.py -v passes
- [ ] custom_commands.db created in Application Support directory
- [ ] Syncer detects file changes and updates registry
</verification>

<success_criteria>

- All TDD tests pass (RED-GREEN-REFACTOR cycle followed)
- CustomCommandRegistry provides CRUD with SQLite persistence
- CommandSyncer monitors ~/.claude/agents/ and updates registry
- Integration test verifies end-to-end flow
- Code follows Phase 2/4 patterns (WAL mode, async init, UTC timestamps, idempotent ops)
- No new test failures or skipped tests introduced
</success_criteria>

<output>
After completion, create `.planning/phases/09-advanced-features/09-01-SUMMARY.md`
</output>
