---
phase: 09-advanced-features
plan: 03
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/custom_commands/commands.py
  - tests/test_custom_commands.py
autonomous: true

must_haves:
  truths:
    - "User can list available custom commands"
    - "User can view details of a specific custom command"
    - "User can invoke custom command from Signal"
    - "Custom command executes in Claude Code session"
  artifacts:
    - path: "src/custom_commands/commands.py"
      provides: "/custom command handler (list, show, invoke)"
      exports: ["CustomCommands"]
      min_lines: 60
    - path: "tests/test_custom_commands.py"
      provides: "TDD tests for custom command interface"
      min_lines: 80
  key_links:
    - from: "src/custom_commands/commands.py"
      to: "src/custom_commands/registry.py"
      via: "retrieve available commands from registry"
      pattern: "registry\\.list_commands|registry\\.get_command"
    - from: "src/custom_commands/commands.py"
      to: "src/claude/orchestrator.py"
      via: "execute custom command via orchestrator"
      pattern: "orchestrator\\.execute_custom"
---

<objective>
Build custom command interface enabling users to list, view, and invoke custom commands from Signal.

Purpose: Provide Signal command handlers for custom command discovery and execution.
Output: CustomCommands handler with /custom list, /custom show, /custom invoke.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase patterns
@.planning/phases/04-multi-project/04-02-SUMMARY.md  # ThreadCommands pattern (handle, help)
@.planning/phases/08-notification-system/08-03-SUMMARY.md  # NotificationCommands pattern
@.planning/phases/09-advanced-features/09-01-SUMMARY.md  # CustomCommandRegistry

# Key architectural decisions
- Follow SessionCommands pattern for command handlers (Phase 2)
- async handle(thread_id, message) signature (Phase 4)
- Truncate IDs to 8 chars for mobile display (Phase 2-8)
- Mobile-friendly formatting with emoji (Phase 6)
- Help text with persistence note (Phase 4)

# Custom command requirements
- /custom list ‚Üí shows available commands with names and descriptions
- /custom show <name> ‚Üí displays command details (parameters, usage)
- /custom invoke <name> <args> ‚Üí executes command in current session
- Commands stored in registry from Plan 01
- Execution via ClaudeOrchestrator (Phase 3)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CustomCommands handler with TDD</name>
  <files>tests/test_custom_commands.py, src/custom_commands/commands.py</files>
  <action>
    RED: Write failing tests for CustomCommands:
    - test_handle_list() ‚Üí "/custom list" returns formatted list of commands
    - test_handle_show() ‚Üí "/custom show gsd:plan" returns command details
    - test_handle_show_not_found() ‚Üí "/custom show unknown" returns "not found" message
    - test_handle_invoke() ‚Üí "/custom invoke gsd:plan" executes command
    - test_handle_invoke_requires_session() ‚Üí returns error if no active session
    - test_handle_help() ‚Üí "/custom help" returns usage instructions
    - test_unknown_subcommand() ‚Üí "/custom unknown" returns help text

    GREEN: Implement CustomCommands:
    - __init__(self, registry: CustomCommandRegistry, orchestrator: ClaudeOrchestrator)
    - async handle(self, thread_id: str, message: str) ‚Üí str
    - Parse subcommands: list, show <name>, invoke <name> <args>, help
    - list() ‚Üí registry.list_commands() ‚Üí format with emoji (üìã custom command name: description)
    - show(name) ‚Üí registry.get_command(name) ‚Üí format details (parameters, description, usage)
    - invoke(name, args, thread_id) ‚Üí orchestrator.execute_custom_command(name, args, thread_id)
    - help() ‚Üí return usage text with examples
    - Mobile-friendly formatting (320px width constraint from Phase 6)
    - Truncate command names if > 30 chars for mobile display

    REFACTOR: Extract formatting helpers if needed.

    Follow ThreadCommands pattern from Phase 4 (async handle, subcommand routing).
    Emoji for visual distinction: üìã for list, üìÑ for show, ‚ñ∂Ô∏è for invoke.
    Error handling: command not found, no active session, invalid args.
  </action>
  <verify>pytest tests/test_custom_commands.py -v passes all tests</verify>
  <done>CustomCommands handles /custom list/show/invoke, formats for mobile, executes via orchestrator</done>
</task>

<task type="auto">
  <name>Task 2: Extend ClaudeOrchestrator for custom command execution</name>
  <files>src/claude/orchestrator.py, tests/test_claude_orchestrator.py</files>
  <action>
    Add execute_custom_command method to ClaudeOrchestrator:
    - execute_custom_command(self, command_name: str, args: str, thread_id: str) ‚Üí None
    - Load command from registry
    - Format command invocation: "/{command_name} {args}"
    - Send to Claude CLI via bridge
    - Stream responses back to Signal (existing streaming logic)

    Update tests:
    - test_execute_custom_command() ‚Üí sends formatted command to bridge
    - test_custom_command_streams_response() ‚Üí responses streamed to Signal

    Reuse existing execute_command() streaming infrastructure from Phase 3.
    Custom commands are just special-case Claude commands (slash commands).
  </action>
  <verify>pytest tests/test_claude_orchestrator.py -v passes with new tests</verify>
  <done>Orchestrator can execute custom commands via existing streaming infrastructure</done>
</task>

<task type="auto">
  <name>Task 3: Integration test for custom command flow</name>
  <files>tests/test_custom_command_flow.py</files>
  <action>
    Write integration test verifying end-to-end custom command execution:
    - Setup: Create test command in registry
    - Test scenario:
      1. /custom list ‚Üí verify command appears
      2. /custom show test-cmd ‚Üí verify details displayed
      3. /custom invoke test-cmd arg1 ‚Üí verify orchestrator.execute_custom_command called
      4. Verify command sent to bridge
      5. Verify response streamed to Signal

    Use mocks for ClaudeOrchestrator and SignalClient.
    Verify message formatting matches mobile UX patterns (Phase 6).
  </action>
  <verify>pytest tests/test_custom_command_flow.py -v passes</verify>
  <done>End-to-end flow: list ‚Üí show ‚Üí invoke ‚Üí execute ‚Üí stream works correctly</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] pytest tests/test_custom_commands.py -v passes
- [ ] pytest tests/test_claude_orchestrator.py -v passes (with new custom command tests)
- [ ] pytest tests/test_custom_command_flow.py -v passes
- [ ] /custom list returns formatted command list
- [ ] /custom show returns command details
- [ ] /custom invoke executes command via orchestrator
- [ ] Mobile-friendly formatting (emoji, truncation, 320px width)
</verification>

<success_criteria>

- All TDD tests pass (RED-GREEN-REFACTOR cycle followed)
- CustomCommands handles list/show/invoke subcommands
- ClaudeOrchestrator executes custom commands via existing streaming
- Integration test verifies end-to-end flow
- Code follows Phase 3/4/6 patterns (orchestrator streaming, command handler, mobile UX)
- No new test failures or skipped tests introduced
</success_criteria>

<output>
After completion, create `.planning/phases/09-advanced-features/09-03-SUMMARY.md`
</output>
