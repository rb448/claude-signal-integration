---
phase: 02-session-management-durable-execution
plan: 07
type: execute
wave: 1
depends_on: []
files_modified:
  - src/claude/process.py
  - src/session/commands.py
  - src/session/manager.py
autonomous: true
gap_closure: true
---

<objective>
Implement conversation history restoration for session resume.

Purpose: Enable true session resumption where conversation context persists across pauses and restarts.
Output: Users can resume sessions and continue conversations from where they left off.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Gap Context (from 02-VERIFICATION.md)
**Gap 2**: Conversation history not preserved on resume
- Session.context exists as JSON blob in database (currently always {})
- SessionCommands._resume() gets session from DB but doesn't use context
- ClaudeProcess.start() spawned but has no parameter for conversation history
- Result: "Resume" creates fresh session - user loses conversation history

**Root causes:**
1. ClaudeProcess.start() doesn't accept conversation history parameter
2. SessionCommands._resume() doesn't pass session.context to ClaudeProcess
3. SessionManager never populates session.context with conversation history

# Existing Implementation
@src/claude/process.py (start() method at lines 41-71)
@src/session/commands.py (_resume() method around lines 134-163)
@src/session/manager.py (Session dataclass, update() method)

# Architecture Decision
For Phase 2, conversation history restoration is PLACEHOLDER implementation:
- ClaudeProcess.start() will accept history parameter but NOT use it yet
- SessionManager.update_context() will store conversation history
- SessionCommands will wire the flow: get context → pass to process
- Actual conversation restoration to Claude Code CLI deferred to Phase 3 (Claude integration)

Rationale: Phase 2 focused on session persistence infrastructure. Phase 3 implements bidirectional Claude communication, which is where conversation restoration belongs architecturally.

This plan creates the WIRING so Phase 3 can plug in conversation restoration without refactoring the session layer.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add conversation history parameter to ClaudeProcess</name>
  <files>src/claude/process.py</files>
  <action>
Modify ClaudeProcess.start() method (lines 41-71):

1. Add conversation_history parameter:
   ```python
   async def start(self, conversation_history: Optional[dict] = None) -> None:
   ```

2. Store conversation history in instance variable:
   ```python
   self._conversation_history = conversation_history or {}
   ```

3. Add comment explaining Phase 3 usage:
   ```python
   # conversation_history will be used in Phase 3 to restore Claude Code CLI context
   # For now, stored but not applied (Phase 3: Claude integration implements restoration)
   ```

4. Keep existing subprocess spawn logic unchanged (lines 63-69)

Context:
- conversation_history is dict (matches Session.context JSON blob type)
- Optional parameter: None for new sessions, populated dict for resume
- Phase 2 focused on persistence infrastructure, not Claude CLI integration
- Phase 3 (Claude Code Integration) will implement actual conversation restoration to CLI
  </action>
  <verify>
1. ClaudeProcess.start() accepts conversation_history parameter
2. Parameter stored in instance variable _conversation_history
3. Existing subprocess spawn logic unchanged (no behavior change)
4. Type hints correct: Optional[dict] = None
  </verify>
  <done>
- ClaudeProcess.start() signature updated with conversation_history parameter
- Instance variable _conversation_history stores history
- Comment explains Phase 3 usage
- No behavior change (parameter stored but not used yet)
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire conversation history in SessionCommands._resume()</name>
  <files>src/session/commands.py</files>
  <action>
Modify _resume() method (around lines 134-163):

1. Extract conversation history from session before spawning process:
   ```python
   conversation_history = session.context.get("conversation_history", {})
   ```

2. Pass history to ClaudeProcess.start():
   Change line 159 (or equivalent) from:
   ```python
   await process.start()
   ```
   To:
   ```python
   await process.start(conversation_history=conversation_history)
   ```

3. Add comment explaining storage:
   ```python
   # conversation_history extracted from session.context (populated by SessionManager)
   # Phase 3 will implement actual restoration to Claude Code CLI
   ```

Context:
- session.context is dict with optional "conversation_history" key
- get() with default {} handles empty context gracefully
- Matches ClaudeProcess.start() signature from Task 1
- Phase 3 will populate session.context during active conversations
  </action>
  <verify>
1. _resume() extracts conversation_history from session.context
2. conversation_history passed to process.start()
3. Handles empty context gracefully (defaults to {})
4. No exceptions raised for missing "conversation_history" key
  </verify>
  <done>
- _resume() wired to pass conversation_history to ClaudeProcess
- Graceful handling of empty session.context
- Comment explains Phase 3 usage
- Flow complete: DB → SessionCommands → ClaudeProcess (storage wired, usage deferred)
  </done>
</task>

<task type="auto">
  <name>Task 3: Add SessionManager.update_context() method</name>
  <files>src/session/manager.py</files>
  <action>
Add new method to SessionManager class:

```python
async def update_context(
    self,
    session_id: str,
    conversation_history: dict
) -> None:
    """
    Update session conversation context.

    Stores conversation history for session resumption.
    Called by Claude integration (Phase 3) during active conversations.

    Args:
        session_id: Session UUID
        conversation_history: Dict containing conversation turns

    Raises:
        SessionNotFoundError: If session doesn't exist
    """
    session = await self.get(session_id)
    if not session:
        raise SessionNotFoundError(f"Session {session_id} not found")

    # Update context JSON blob with conversation history
    updated_context = {**session.context, "conversation_history": conversation_history}

    async with aiosqlite.connect(self._db_path) as db:
        await db.execute(
            "UPDATE sessions SET context = ? WHERE id = ?",
            (json.dumps(updated_context), session_id)
        )
        await db.commit()

    self._log.info(
        "session_context_updated",
        session_id=session_id,
        history_length=len(conversation_history)
    )
```

Context:
- Async method matches SessionManager pattern
- Uses existing aiosqlite connection pattern
- Updates session.context JSON blob (existing field, currently always {})
- Phase 3 will call this during active conversations to persist history
- Session.context is JSON blob, supports arbitrary keys
  </action>
  <verify>
1. update_context() method exists in SessionManager
2. Method signature: async def update_context(session_id: str, conversation_history: dict)
3. Updates session.context with conversation_history key
4. Raises SessionNotFoundError for invalid session_id
5. Logs context update with history length
  </verify>
  <done>
- SessionManager.update_context() method created
- Updates session.context JSON blob with conversation_history
- Error handling for missing sessions
- Logging for debugging
- Phase 3 ready to call this method during conversations
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] ClaudeProcess.start() accepts conversation_history parameter
- [ ] SessionCommands._resume() passes conversation_history to process.start()
- [ ] SessionManager.update_context() exists and updates session.context
- [ ] No new test failures introduced
- [ ] No behavior change (wiring exists, actual restoration deferred to Phase 3)
</verification>

<success_criteria>
- All tasks completed
- Conversation history flow wired: SessionManager.update_context() → DB → _resume() → ClaudeProcess
- No behavior change in Phase 2 (placeholder implementation for Phase 3)
- Architecture ready for Phase 3 to implement actual conversation restoration
- Gap 2 from VERIFICATION.md closed (wiring gap resolved, feature gap deferred to Phase 3)
</success_criteria>

<output>
After completion, create `.planning/phases/02-session-management-durable-execution/02-07-SUMMARY.md`
</output>
