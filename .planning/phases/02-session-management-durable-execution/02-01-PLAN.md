---
phase: 02-session-management-durable-execution
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified: [src/session/manager.py, tests/test_session_manager.py, src/session/schema.sql]
autonomous: true

must_haves:
  truths:
    - "User can create new session with unique ID"
    - "Session state persists to database"
    - "User can list all sessions"
    - "User can retrieve session by ID"
  artifacts:
    - path: "src/session/manager.py"
      provides: "Session lifecycle management"
      min_lines: 80
      exports: ["SessionManager"]
    - path: "src/session/schema.sql"
      provides: "SQLite schema for sessions table"
      contains: "CREATE TABLE sessions"
    - path: "tests/test_session_manager.py"
      provides: "Unit tests for SessionManager"
      min_lines: 100
  key_links:
    - from: "SessionManager.create()"
      to: "SQLite database"
      via: "INSERT into sessions table"
      pattern: "INSERT INTO sessions"
    - from: "SessionManager.get()"
      to: "SQLite database"
      via: "SELECT from sessions table"
      pattern: "SELECT .* FROM sessions WHERE id"
---

<objective>
Implement session persistence layer with SQLite storage using TDD methodology.

Purpose: Establish durable session storage that survives daemon restarts, forming foundation for crash recovery in subsequent plans.
Output: SessionManager class with create/get/list operations backed by SQLite, with comprehensive test coverage from TDD cycle.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-signal-core-infrastructure/01-01-SUMMARY.md
@.planning/phases/01-signal-core-infrastructure/01-03-SUMMARY.md

**From Phase 1:**
- Python 3.11+ asyncio architecture established
- pydantic for data validation patterns
- structlog for logging
- Docker Compose for service management

**Phase 2 Context:**
Requirements: SESS-01, SESS-03, SESS-06
TDD Strategy: All session state machine logic follows RED-GREEN-REFACTOR
</context>

<feature>
  <name>Session Persistence with SQLite</name>
  <files>src/session/manager.py, tests/test_session_manager.py, src/session/schema.sql</files>
  <behavior>
    SessionManager provides CRUD operations for session state:

    **Cases:**
    - create(project_path, thread_id) → Session with unique ID, CREATED status, timestamp
    - get(session_id) → Session if exists, None otherwise
    - list() → all sessions ordered by created_at DESC
    - update(session_id, status, context) → updated Session
    - Database survives process restart (persistent storage)
    - Concurrent creates generate unique IDs (no collisions)

    **Session Model:**
    ```python
    @dataclass
    class Session:
        id: str  # UUID4
        project_path: str
        thread_id: str
        status: SessionStatus  # CREATED, ACTIVE, PAUSED, TERMINATED
        context: dict  # JSON blob for conversation history
        created_at: datetime
        updated_at: datetime
    ```

    **Expected Behaviors:**
    - create() inserts row, returns Session with generated ID
    - get() returns None for missing ID (not exception)
    - update() uses atomic write-to-temp-then-rename for crash safety
    - Database path: ~/.claude-signal/sessions.db
  </behavior>
  <implementation>
    **RED Phase - Write Failing Tests:**
    1. Test framework setup: pytest, pytest-asyncio (if not exists from Phase 1)
    2. Test create() → verify Session returned with UUID, CREATED status, timestamps
    3. Test get() → verify retrieval works, None for missing
    4. Test list() → verify ordering by created_at DESC
    5. Test update() → verify status and context changes persist
    6. Test persistence → create session, restart SessionManager, verify session still exists
    7. Test concurrent creates → verify unique IDs generated

    **GREEN Phase - Implement to Pass:**
    1. Create schema.sql with sessions table (id, project_path, thread_id, status, context JSON, created_at, updated_at)
    2. Implement SessionManager.__init__() to connect to SQLite, create table if not exists
    3. Implement create() with INSERT, UUID generation, timestamps
    4. Implement get() with SELECT WHERE id
    5. Implement list() with SELECT ORDER BY created_at DESC
    6. Implement update() with UPDATE WHERE id
    7. Use sqlite3 connection with WAL mode for concurrent access

    **REFACTOR Phase (if needed):**
    - Extract database connection to separate module if code duplication emerges
    - Add connection pooling if tests reveal performance issues
    - Only refactor if obvious improvements exist AND tests still pass
  </implementation>
</feature>

<verification>
Before declaring plan complete:
- [ ] All tests pass: pytest tests/test_session_manager.py -v
- [ ] Test file created BEFORE implementation file (git log confirms)
- [ ] Database file created at ~/.claude-signal/sessions.db
- [ ] No errors or warnings from pytest
</verification>

<success_criteria>
- Failing test written and committed (RED)
- Implementation passes all tests (GREEN)
- Refactor complete if needed (REFACTOR)
- All 2-3 commits present in git log
- SessionManager can create, retrieve, list, and update sessions
- Sessions persist across SessionManager restarts
</success_criteria>

<output>
After completion, create `.planning/phases/02-session-management-durable-execution/02-01-SUMMARY.md` with:
- RED: What tests were written, why they failed initially
- GREEN: What implementation made them pass
- REFACTOR: What cleanup was done (if any)
- Commits: List of commits produced (test → feat → refactor)
</output>
