---
phase: 02-session-management-durable-execution
plan: 05
type: execute
wave: 4
depends_on: ["02-01", "02-02", "02-03", "02-04"]
files_modified: [src/daemon/service.py, src/session/commands.py, tests/test_session_commands.py]
autonomous: true

must_haves:
  truths:
    - "User can send /session start <path> to create new session"
    - "User can send /session list to view all sessions"
    - "User can send /session resume <id> to continue session"
    - "Commands integrate with Signal message handler"
  artifacts:
    - path: "src/session/commands.py"
      provides: "Session command handlers"
      min_lines: 80
      exports: ["SessionCommands"]
    - path: "tests/test_session_commands.py"
      provides: "Tests for command handlers"
      min_lines: 80
    - path: "src/daemon/service.py"
      provides: "Daemon with session commands integrated"
      contains: "SessionCommands"
  key_links:
    - from: "SignalBot.on_message()"
      to: "SessionCommands.handle()"
      via: "Route /session commands"
      pattern: "/session"
    - from: "SessionCommands.start()"
      to: "SessionManager.create()"
      via: "Create session"
      pattern: "manager\\.create"
---

<objective>
Integrate session management into Signal bot with user-facing commands.

Purpose: Wire session CRUD operations to Signal commands, enabling users to start/list/resume sessions from mobile.
Output: Working /session commands in Signal bot that create, list, and resume sessions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-signal-core-infrastructure/01-03-SUMMARY.md
@.planning/phases/01-signal-core-infrastructure/01-04-SUMMARY.md
@.planning/phases/02-session-management-durable-execution/02-01-SUMMARY.md
@.planning/phases/02-session-management-durable-execution/02-02-SUMMARY.md
@.planning/phases/02-session-management-durable-execution/02-03-SUMMARY.md
@.planning/phases/02-session-management-durable-execution/02-04-SUMMARY.md

**From Phase 1:**
- SignalBot.on_message() handler receives messages
- MessageQueue for rate limiting
- PhoneVerifier for auth

**From Phase 2 Plans:**
- SessionManager with CRUD operations
- SessionLifecycle with state transitions
- ClaudeProcess for subprocess spawning
- CrashRecovery for automatic recovery

**Phase 2 Requirements:**
SESS-01: User can start new Claude Code session from Signal message
SESS-02: User can resume existing Claude Code session

**Commands to implement:**
- /session start <project_path> - create new session, transition to ACTIVE
- /session list - show all sessions with status
- /session resume <session_id> - transition PAUSED → ACTIVE
- /session stop <session_id> - transition ACTIVE → TERMINATED
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SessionCommands class with command handlers</name>
  <files>src/session/commands.py, tests/test_session_commands.py</files>
  <action>
    Create SessionCommands class that parses and handles /session commands:

    ```python
    class SessionCommands:
        def __init__(self, session_manager: SessionManager, session_lifecycle: SessionLifecycle, claude_process_factory):
            self.manager = session_manager
            self.lifecycle = session_lifecycle
            self.processes: dict[str, ClaudeProcess] = {}  # session_id → process

        async def handle(self, thread_id: str, message: str) -> str:
            # Parse: /session <subcommand> [args]
            parts = message.strip().split()
            if len(parts) < 2:
                return self._help()

            subcommand = parts[1]
            if subcommand == "start":
                return await self._start(thread_id, parts[2] if len(parts) > 2 else None)
            elif subcommand == "list":
                return await self._list()
            elif subcommand == "resume":
                return await self._resume(parts[2] if len(parts) > 2 else None)
            elif subcommand == "stop":
                return await self._stop(parts[2] if len(parts) > 2 else None)
            else:
                return self._help()

        async def _start(self, thread_id: str, project_path: str) -> str:
            # Validate project_path exists
            # Create session via manager
            # Transition CREATED → ACTIVE
            # Spawn ClaudeProcess
            # Return: "Started session {id} for {project_path}"

        async def _list(self) -> str:
            # Get all sessions from manager
            # Format: "ID | Status | Project\n..."
            # Return formatted table

        async def _resume(self, session_id: str) -> str:
            # Get session, verify status=PAUSED
            # Transition PAUSED → ACTIVE
            # Spawn ClaudeProcess if not running
            # Return: "Resumed session {id}"

        async def _stop(self, session_id: str) -> str:
            # Get session, verify status=ACTIVE
            # Stop ClaudeProcess
            # Transition ACTIVE → TERMINATED
            # Return: "Stopped session {id}"
    ```

    Write tests first:
    - test_start_creates_session_and_spawns_process
    - test_list_shows_all_sessions
    - test_resume_transitions_paused_to_active
    - test_stop_terminates_process_and_session
    - test_invalid_subcommand_returns_help
    - test_start_without_path_returns_error

    Use pytest with mocks for SessionManager/SessionLifecycle.
  </action>
  <verify>pytest tests/test_session_commands.py -v</verify>
  <done>SessionCommands handles all /session subcommands with tests passing</done>
</task>

<task type="auto">
  <name>Task 2: Integrate SessionCommands into daemon service</name>
  <files>src/daemon/service.py</files>
  <action>
    Update SignalDaemon to route /session commands to SessionCommands:

    In SignalDaemon.__init__():
    ```python
    self.session_manager = SessionManager()
    self.session_lifecycle = SessionLifecycle(self.session_manager)
    self.crash_recovery = CrashRecovery(self.session_manager, self.session_lifecycle)
    self.session_commands = SessionCommands(
        self.session_manager,
        self.session_lifecycle,
        lambda sid, path: ClaudeProcess(sid, path)
    )
    ```

    In SignalDaemon.run():
    ```python
    # After WebSocket connect, before receive loop:
    recovered = await self.crash_recovery.recover()
    if recovered:
        await self.signal_client.send_message(
            self.authorized_number,
            f"⚠️ Recovered {len(recovered)} sessions after restart"
        )
    ```

    In on_message() handler:
    ```python
    async def on_message(self, sender: str, message: str, thread_id: str):
        # Existing auth check
        if not self.phone_verifier.is_authorized(sender):
            return

        # Route /session commands
        if message.startswith("/session"):
            response = await self.session_commands.handle(thread_id, message)
            await self.signal_client.send_message(sender, response)
            return

        # Existing queue logic for other messages
        await self.message_queue.enqueue(...)
    ```

    Verify daemon still starts/stops cleanly with session components added.
  </action>
  <verify>python -m src.daemon.service (starts without errors, Ctrl+C to stop)</verify>
  <done>Daemon integrates SessionCommands, handles /session commands, runs crash recovery on startup</done>
</task>

<task type="auto">
  <name>Task 3: Add integration test for full session workflow</name>
  <files>tests/test_session_integration.py</files>
  <action>
    Create end-to-end test for session lifecycle:

    ```python
    @pytest.mark.asyncio
    async def test_session_workflow_start_to_stop():
        # Setup
        daemon = SignalDaemon(...)  # Use test config

        # 1. Start session
        response = await daemon.session_commands.handle("thread-1", "/session start /tmp/test-project")
        assert "Started session" in response
        session_id = extract_session_id(response)

        # 2. List shows new session
        response = await daemon.session_commands.handle("thread-1", "/session list")
        assert session_id in response
        assert "ACTIVE" in response

        # 3. Stop session
        response = await daemon.session_commands.handle("thread-1", f"/session stop {session_id}")
        assert "Stopped session" in response

        # 4. List shows TERMINATED
        response = await daemon.session_commands.handle("thread-1", "/session list")
        assert "TERMINATED" in response

    @pytest.mark.asyncio
    async def test_crash_recovery_workflow():
        # Setup
        daemon1 = SignalDaemon(...)

        # Start session
        response = await daemon1.session_commands.handle("t1", "/session start /tmp/proj")
        session_id = extract_session_id(response)

        # Simulate crash (stop daemon without clean shutdown)
        del daemon1

        # Restart daemon
        daemon2 = SignalDaemon(...)
        recovered = await daemon2.crash_recovery.recover()
        assert session_id in recovered

        # Session now PAUSED
        session = daemon2.session_manager.get(session_id)
        assert session.status == SessionStatus.PAUSED
    ```

    Use tempfile.TemporaryDirectory() for test databases.
    Use pytest fixtures for daemon setup/teardown.
  </action>
  <verify>pytest tests/test_session_integration.py -v</verify>
  <done>Integration tests pass, full session lifecycle works end-to-end</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] pytest tests/test_session_commands.py -v passes
- [ ] pytest tests/test_session_integration.py -v passes
- [ ] Daemon starts with session components
- [ ] /session start creates session and spawns process
- [ ] /session list shows all sessions
- [ ] /session resume works for PAUSED sessions
- [ ] /session stop terminates cleanly
- [ ] Crash recovery runs on daemon startup
</verification>

<success_criteria>
- All tasks completed
- All tests pass
- Session commands work from Signal
- Crash recovery integrated
- No errors or warnings
- Phase 2 requirements SESS-01, SESS-02, SESS-03, SESS-04, SESS-05 satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/02-session-management-durable-execution/02-05-SUMMARY.md`
</output>
