---
phase: 02-session-management-durable-execution
plan: 04
type: tdd
wave: 3
depends_on: ["02-01", "02-02", "02-03"]
files_modified: [src/session/recovery.py, tests/test_recovery.py]
autonomous: true

must_haves:
  truths:
    - "System detects daemon crash on restart"
    - "ACTIVE sessions restore to PAUSED status automatically"
    - "Session context survives crash"
    - "User is notified of recovered sessions"
  artifacts:
    - path: "src/session/recovery.py"
      provides: "Crash recovery logic"
      min_lines: 70
      exports: ["CrashRecovery"]
    - path: "tests/test_recovery.py"
      provides: "Unit tests for crash recovery"
      min_lines: 100
  key_links:
    - from: "CrashRecovery.detect_crash()"
      to: "SessionManager.list()"
      via: "Find ACTIVE sessions"
      pattern: "list.*status.*ACTIVE"
    - from: "CrashRecovery.recover()"
      to: "SessionLifecycle.transition()"
      via: "ACTIVE → PAUSED"
      pattern: "transition.*PAUSED"
---

<objective>
Implement crash recovery that auto-pauses ACTIVE sessions on daemon restart using TDD.

Purpose: Prevent data loss when daemon crashes - sessions in ACTIVE state at crash time should gracefully transition to PAUSED for user resume.
Output: CrashRecovery class with detect/recover logic, backed by comprehensive tests written BEFORE implementation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-session-management-durable-execution/02-01-SUMMARY.md
@.planning/phases/02-session-management-durable-execution/02-02-SUMMARY.md
@.planning/phases/02-session-management-durable-execution/02-03-SUMMARY.md

**From 02-01:**
- SessionManager with list/get/update operations
- SQLite persistence survives restarts

**From 02-02:**
- SessionLifecycle with state transition rules
- ACTIVE → PAUSED is valid transition

**From 02-03:**
- ClaudeProcess for subprocess management
- Processes don't survive daemon crash (orphaned)

**Phase 2 Requirements:**
SESS-05: System automatically recovers session state after crash or restart

**TDD Focus:**
Recovery logic is core business logic → write tests FIRST
</context>

<feature>
  <name>Crash Recovery</name>
  <files>src/session/recovery.py, tests/test_recovery.py</files>
  <behavior>
    CrashRecovery detects and recovers from daemon crashes:

    **Detection Logic:**
    - On daemon startup, check for sessions with status=ACTIVE
    - ACTIVE sessions indicate daemon crashed (sessions not cleanly terminated)
    - CREATED/PAUSED/TERMINATED sessions indicate normal state

    **Recovery Logic:**
    - For each ACTIVE session: transition to PAUSED
    - Record recovery timestamp in session context
    - Return list of recovered session IDs

    **Test Cases:**
    ```python
    # Scenario 1: Clean startup (no ACTIVE sessions)
    manager.create(project_path="/proj1", thread_id="t1")  # CREATED
    recovery = CrashRecovery(manager, lifecycle)
    recovered = recovery.recover()
    assert recovered == []  # No recovery needed

    # Scenario 2: Crash recovery (ACTIVE sessions exist)
    session = manager.create(project_path="/proj2", thread_id="t2")
    lifecycle.transition(session.id, CREATED, ACTIVE)  # Simulate running
    # Daemon crashes here...
    # Daemon restarts:
    recovery = CrashRecovery(manager, lifecycle)
    recovered = recovery.recover()
    assert session.id in recovered
    updated = manager.get(session.id)
    assert updated.status == SessionStatus.PAUSED
    assert "recovered_at" in updated.context

    # Scenario 3: Multiple ACTIVE sessions
    s1 = create_and_activate(...)
    s2 = create_and_activate(...)
    # Crash + restart
    recovered = recovery.recover()
    assert len(recovered) == 2
    ```

    **Notification:**
    - Recovery returns list of session IDs
    - Caller (daemon) sends Signal message: "Recovered N sessions after crash"
  </behavior>
  <implementation>
    **RED Phase - Write Failing Tests:**
    1. Test clean startup (no ACTIVE sessions) → recovery returns empty list
    2. Test crash with one ACTIVE session → transitions to PAUSED, adds recovered_at
    3. Test crash with multiple ACTIVE sessions → all transition to PAUSED
    4. Test crash with mix of statuses → only ACTIVE transition, others unchanged
    5. Test recovered_at timestamp exists in session context
    6. Test recovery is idempotent (calling twice doesn't re-recover)
    7. Test recovery with database error → raises, doesn't corrupt state

    **GREEN Phase - Implement to Pass:**
    1. Create CrashRecovery class with __init__(session_manager, session_lifecycle)
    2. Implement detect_crashed_sessions() → list ACTIVE sessions from DB
    3. Implement recover():
       - For each ACTIVE session:
         - transition(session_id, ACTIVE, PAUSED)
         - Add recovered_at timestamp to session.context
       - Return list of recovered session IDs
    4. Handle edge cases (DB errors, concurrent access)

    **REFACTOR Phase (if needed):**
    - Extract notification message formatting if code duplicates
    - Add structured logging for recovery events
  </implementation>
</feature>

<verification>
Before declaring plan complete:
- [ ] pytest tests/test_recovery.py -v passes
- [ ] Test file created BEFORE implementation file (git log)
- [ ] Clean startup returns empty recovery list
- [ ] Crash scenario recovers ACTIVE → PAUSED
- [ ] Multiple sessions recovered correctly
- [ ] recovered_at timestamp added to context
</verification>

<success_criteria>
- Failing tests written and committed (RED)
- Implementation passes all tests (GREEN)
- Refactor complete if needed (REFACTOR)
- All 2-3 commits present
- CrashRecovery detects and recovers ACTIVE sessions
- Recovery is idempotent and safe
</success_criteria>

<output>
After completion, create `.planning/phases/02-session-management-durable-execution/02-04-SUMMARY.md`
</output>
