---
phase: 02-session-management-durable-execution
plan: 02
type: tdd
wave: 2
depends_on: ["02-01"]
files_modified: [src/session/lifecycle.py, tests/test_lifecycle.py]
autonomous: true

must_haves:
  truths:
    - "Session transitions through valid states only (CREATED → ACTIVE → PAUSED → ACTIVE → TERMINATED)"
    - "Invalid transitions raise StateTransitionError"
    - "State changes persist to database"
    - "User can pause active session"
    - "User can resume paused session"
  artifacts:
    - path: "src/session/lifecycle.py"
      provides: "Session state machine with transition rules"
      min_lines: 60
      exports: ["SessionLifecycle", "StateTransitionError"]
    - path: "tests/test_lifecycle.py"
      provides: "Unit tests for state machine"
      min_lines: 120
  key_links:
    - from: "SessionLifecycle.transition()"
      to: "SessionManager.update()"
      via: "Update session status in database"
      pattern: "manager\\.update\\(.*status"
---

<objective>
Implement session state machine with valid transition rules using TDD.

Purpose: Enforce session lifecycle constraints (prevent invalid state transitions like TERMINATED → ACTIVE), ensuring session integrity.
Output: SessionLifecycle class with transition validation, backed by tests written BEFORE implementation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-session-management-durable-execution/02-01-SUMMARY.md

**From 02-01:**
- SessionManager with CRUD operations
- Session model with SessionStatus enum
- SQLite persistence at ~/.claude-signal/sessions.db

**Phase 2 Requirements:**
SESS-03: System manages session lifecycle (create/resume/terminate) reliably

**TDD Focus:**
State machine logic is core business logic → write tests FIRST
</context>

<feature>
  <name>Session State Machine</name>
  <files>src/session/lifecycle.py, tests/test_lifecycle.py</files>
  <behavior>
    SessionLifecycle enforces valid state transitions:

    **Valid Transitions:**
    - CREATED → ACTIVE (session starts)
    - ACTIVE → PAUSED (user pauses work)
    - PAUSED → ACTIVE (user resumes)
    - ACTIVE → TERMINATED (session ends normally)
    - PAUSED → TERMINATED (session ends from pause)
    - CREATED → TERMINATED (session cancelled before start)

    **Invalid Transitions (raise StateTransitionError):**
    - TERMINATED → any state (terminal state)
    - CREATED → PAUSED (can't pause before active)
    - Any transition to CREATED (can't go back to initial state)

    **Test Cases:**
    ```python
    # Valid
    lifecycle.transition("session-123", SessionStatus.CREATED, SessionStatus.ACTIVE)  # OK
    lifecycle.transition("session-123", SessionStatus.ACTIVE, SessionStatus.PAUSED)   # OK
    lifecycle.transition("session-123", SessionStatus.PAUSED, SessionStatus.ACTIVE)   # OK
    lifecycle.transition("session-123", SessionStatus.ACTIVE, SessionStatus.TERMINATED)  # OK

    # Invalid
    lifecycle.transition("session-123", SessionStatus.TERMINATED, SessionStatus.ACTIVE)  # raises StateTransitionError
    lifecycle.transition("session-123", SessionStatus.CREATED, SessionStatus.PAUSED)     # raises StateTransitionError
    ```

    **Persistence:**
    - transition() calls SessionManager.update() to persist new status
    - Transition succeeds only if database update succeeds
  </behavior>
  <implementation>
    **RED Phase - Write Failing Tests:**
    1. Test valid transition CREATED → ACTIVE
    2. Test valid transition ACTIVE → PAUSED
    3. Test valid transition PAUSED → ACTIVE
    4. Test valid transition ACTIVE → TERMINATED
    5. Test valid transition PAUSED → TERMINATED
    6. Test invalid transition TERMINATED → ACTIVE raises StateTransitionError
    7. Test invalid transition CREATED → PAUSED raises StateTransitionError
    8. Test invalid transition from any → CREATED raises StateTransitionError
    9. Test transition persists to database (verify via SessionManager.get())
    10. Test transition to same state is idempotent (ACTIVE → ACTIVE allowed)

    **GREEN Phase - Implement to Pass:**
    1. Define StateTransitionError exception
    2. Define valid_transitions dict mapping (from_state, to_state) → bool
    3. Implement SessionLifecycle.__init__(session_manager: SessionManager)
    4. Implement transition(session_id, from_status, to_status):
       - Check from_status matches current DB status (raise if mismatch)
       - Check transition is valid (raise StateTransitionError if not)
       - Call session_manager.update(session_id, to_status)
       - Return updated Session
    5. Handle idempotent transitions (same state OK)
    6. Handle terminal state (TERMINATED) by rejecting any outbound transitions

    **REFACTOR Phase (if needed):**
    - Extract transition rules to separate config if table grows large
    - Add transition event logging if tests reveal debugging difficulty
  </implementation>
</feature>

<verification>
Before declaring plan complete:
- [ ] pytest tests/test_lifecycle.py -v passes
- [ ] Test file created BEFORE implementation file (git log)
- [ ] All valid transitions succeed
- [ ] All invalid transitions raise StateTransitionError
- [ ] State changes persist to database
</verification>

<success_criteria>
- Failing tests written and committed (RED)
- Implementation passes all tests (GREEN)
- Refactor complete if needed (REFACTOR)
- All 2-3 commits present
- State machine enforces lifecycle rules
- Transitions persist to database
</success_criteria>

<output>
After completion, create `.planning/phases/02-session-management-durable-execution/02-02-SUMMARY.md`
</output>
