---
phase: 02-session-management-durable-execution
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - src/daemon/service.py
autonomous: true
gap_closure: true
---

<objective>
Wire session command responses and crash recovery notifications to Signal messaging.

Purpose: Complete user-facing integration by sending feedback to user when commands execute and sessions recover.
Output: Users receive confirmation messages for /session commands and crash recovery notifications via Signal.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Gap Context (from 02-VERIFICATION.md)
**Gap 1**: Session command responses never reach user
- SessionCommands.handle() returns response string (e.g., "Started session abc123")
- Daemon receives response at line 124 but has TODO comment (lines 126-127) instead of sending
- Fix: Call signal_client.send_message(sender, response)

**Gap 3**: Crash recovery notification not sent
- CrashRecovery.recover() works correctly (transitions ACTIVE→PAUSED, adds recovered_at)
- Daemon logs recovered session IDs (lines 163-167) but has TODO comment (lines 168-172)
- Fix: Call signal_client.send_message() with recovery notification

# Existing Implementation
@src/daemon/service.py (lines 115-140, 160-180)
@src/signal/client.py (send_message interface at lines 49-105)
@src/session/commands.py (handle() returns response strings)
@src/session/recovery.py (recover() returns list of recovered session IDs)

# Prior Phase Work
Phase 2 completed session infrastructure (SessionManager, SessionLifecycle, SessionCommands, CrashRecovery, ClaudeProcess).
These wiring gaps are the last step to make the system user-facing.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire session command responses to Signal</name>
  <files>src/daemon/service.py</files>
  <action>
In the on_message() method (lines 122-128):
1. Replace the TODO comment block (lines 126-127) with actual message send
2. Call: await self.signal_client.send_message(sender, response)
3. Keep the existing logger.info for debugging
4. Handle send_message exceptions with try/except to prevent daemon crash

Context:
- sender variable available from on_message() parameter
- response variable contains SessionCommands.handle() return value
- signal_client.send_message(recipient: str, text: str) already exists (lines 49-105 of client.py)
- Exception handling critical: if send fails, log error but don't crash daemon
  </action>
  <verify>
1. Daemon starts without errors
2. /session command executed (test or manual): response message sent to Signal
3. signal_client.send_message() called with correct recipient and response text
4. Exception handling prevents daemon crash if send_message fails
  </verify>
  <done>
- TODO comment removed
- response sent to Signal via signal_client.send_message()
- Exception handling prevents daemon crash
- User receives confirmation message after /session commands
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire crash recovery notification to Signal</name>
  <files>src/daemon/service.py</files>
  <action>
In the run() method (lines 160-173):
1. Replace the commented-out TODO block (lines 168-172) with actual notification send
2. After CrashRecovery.recover() completes and recovered list exists:
   - Call: await self.signal_client.send_message(
       self.phone_verifier.authorized_number,
       f"⚠️ Recovered {len(recovered)} sessions after restart: {', '.join(r[:8] for r in recovered)}"
     )
3. Wrap send in try/except to prevent daemon crash if notification fails
4. Keep existing logger.warning for debugging

Context:
- recovered is list of session IDs (strings) from crash_recovery.recover()
- phone_verifier.authorized_number is the E.164 phone to notify
- Truncate session IDs to first 8 chars for mobile display (matches /session list format)
- Exception handling critical: notification is best-effort, don't crash daemon
  </action>
  <verify>
1. Daemon starts successfully
2. If sessions recovered (test by killing daemon mid-session): notification sent to authorized phone
3. Notification message contains count and truncated session IDs
4. Exception handling prevents daemon crash if send_message fails
  </verify>
  <done>
- TODO comment removed
- Recovery notification sent to authorized user
- Message format: "⚠️ Recovered N sessions after restart: abc12345, def67890"
- Exception handling prevents daemon crash
- User aware of session recovery without manual /session list
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Daemon starts without errors
- [ ] Session command responses sent to Signal (test /session start or /session list)
- [ ] Crash recovery notification sent when sessions recovered (test by daemon kill)
- [ ] Exception handling prevents daemon crash on send_message failure
- [ ] No new test failures introduced
</verification>

<success_criteria>
- All tasks completed
- TODO comments removed from src/daemon/service.py
- Users receive feedback for /session commands via Signal
- Users notified about crash recovery via Signal
- Exception handling prevents daemon crashes
- Gap 1 and Gap 3 from VERIFICATION.md closed
</success_criteria>

<output>
After completion, create `.planning/phases/02-session-management-durable-execution/02-06-SUMMARY.md`
</output>
