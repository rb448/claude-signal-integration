---
phase: 02-session-management-durable-execution
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified: [src/claude/process.py, tests/test_claude_process.py]
autonomous: true

must_haves:
  truths:
    - "Each session spawns isolated Claude Code subprocess"
    - "Process isolation prevents state mixing between sessions"
    - "Subprocess can be started and stopped cleanly"
    - "Subprocess inherits correct working directory"
  artifacts:
    - path: "src/claude/process.py"
      provides: "Claude Code subprocess management"
      min_lines: 50
      exports: ["ClaudeProcess"]
    - path: "tests/test_claude_process.py"
      provides: "Tests for process isolation"
      min_lines: 60
  key_links:
    - from: "ClaudeProcess.start()"
      to: "subprocess.Popen"
      via: "Spawn claude-code CLI"
      pattern: "create_subprocess_exec.*claude"
    - from: "ClaudeProcess.stop()"
      to: "process.terminate()"
      via: "Clean shutdown"
      pattern: "terminate\\(\\)|kill\\(\\)"
---

<objective>
Implement Claude Code subprocess spawning with process isolation.

Purpose: Enable each session to run in dedicated Claude Code process, preventing context mixing between concurrent projects.
Output: ClaudeProcess class that spawns, monitors, and cleanly terminates claude-code CLI subprocesses.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-signal-core-infrastructure/01-01-SUMMARY.md
@.planning/phases/02-session-management-durable-execution/02-01-SUMMARY.md

**From Phase 1:**
- Python asyncio architecture
- structlog for logging

**From 02-01:**
- Session model with project_path
- SessionManager for persistence

**Phase 2 Requirements:**
SESS-04: Each project session runs in isolated Claude Code process

**Implementation Notes:**
- Use asyncio.create_subprocess_exec() for async subprocess management (NOT exec/shell)
- Set cwd=project_path to isolate working directory
- Capture stdout/stderr for debugging
- Graceful shutdown: SIGTERM then SIGKILL after timeout
- Command is hardcoded "claude-code" - no user input in command itself
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ClaudeProcess class with start/stop methods</name>
  <files>src/claude/process.py, src/claude/__init__.py</files>
  <action>
    Create src/claude/ directory and ClaudeProcess class using asyncio subprocess APIs (NOT shell=True).

    Use asyncio.create_subprocess_exec() with explicit command and args array to prevent injection:
    - Command: "claude-code" (hardcoded, no user input)
    - Args: ["--no-browser"] (hardcoded flags)
    - cwd: project_path (user input, but passed as cwd parameter, not in command string)

    Class structure:
    - __init__(session_id, project_path) stores session metadata
    - async start() spawns subprocess with create_subprocess_exec
    - async stop(timeout=5) gracefully terminates (SIGTERM → wait → SIGKILL if hung)
    - is_running property checks process status

    Security note: Using create_subprocess_exec (not subprocess.run or exec()) avoids shell injection.
    The command and arguments are separate parameters, and cwd is a subprocess parameter.

    Avoid: subprocess.run(), os.system(), exec() with shell=True (all vulnerable to injection)
    Use: asyncio.create_subprocess_exec() with command as first arg, args as separate params
  </action>
  <verify>python -c "from src.claude.process import ClaudeProcess; print('Import OK')"</verify>
  <done>ClaudeProcess class exists with start/stop/is_running methods</done>
</task>

<task type="auto">
  <name>Task 2: Write tests for process lifecycle</name>
  <files>tests/test_claude_process.py</files>
  <action>
    Create tests for ClaudeProcess covering start, stop, timeout, and working directory isolation.

    Test cases:
    - test_start_spawns_subprocess: verify process starts and is_running returns True
    - test_stop_terminates_process: verify SIGTERM works, is_running returns False
    - test_stop_with_timeout_kills_process: short timeout forces SIGKILL path
    - test_process_inherits_working_directory: verify cwd isolation (use tmpdir)
    - test_concurrent_processes_isolated: spawn two ClaudeProcess instances, verify separate PIDs

    Use pytest-asyncio for async test support (add to requirements.txt if missing).
    Use tempfile.TemporaryDirectory() for test project directories.
  </action>
  <verify>pytest tests/test_claude_process.py -v</verify>
  <done>All subprocess tests pass, process starts and stops cleanly</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] pytest tests/test_claude_process.py -v passes
- [ ] ClaudeProcess uses create_subprocess_exec (NOT shell=True)
- [ ] ClaudeProcess can start subprocess with correct cwd
- [ ] ClaudeProcess can stop subprocess gracefully (SIGTERM)
- [ ] ClaudeProcess kills hung processes (SIGKILL after timeout)
- [ ] No zombie processes left after tests
</verification>

<success_criteria>
- All tasks completed
- All tests pass
- ClaudeProcess spawns isolated subprocesses safely
- Graceful shutdown works
- No errors or warnings
</success_criteria>

<output>
After completion, create `.planning/phases/02-session-management-durable-execution/02-03-SUMMARY.md`
</output>
