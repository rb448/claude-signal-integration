---
phase: 01-signal-core-infrastructure
plan: 04
type: execute
wave: 1
depends_on: []
files_modified: [src/daemon/service.py, tests/test_daemon.py]
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Daemon continuously receives messages from Signal API"
    - "Received messages flow into MessageQueue for processing"
    - "Message receiving loop runs concurrently with queue processing"
  artifacts:
    - path: "src/daemon/service.py"
      provides: "Async task that calls receive_messages() in continuous loop"
      min_lines: 220
      contains: "receive_task"
    - path: "tests/test_daemon.py"
      provides: "Integration test proving message flow from Signal → daemon → queue"
      exports: ["test_message_receiving_loop"]
  key_links:
    - from: "ServiceDaemon.run()"
      to: "signal_client.receive_messages()"
      via: "async task creation"
      pattern: "create_task.*receive"
    - from: "receive_messages() iterator"
      to: "message_queue.put()"
      via: "async for loop"
      pattern: "async for.*receive_messages.*put"
---

<objective>
Wire message receiving loop to close critical gap preventing Signal messages from reaching daemon.

Purpose: Enable the core bot functionality - listening for and processing incoming Signal messages. Without this wiring, the daemon can send messages but cannot receive them, making it non-functional as a Signal bot.

Output: Daemon with working message ingestion pipeline (Signal API → WebSocket → daemon → queue).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-signal-core-infrastructure/01-VERIFICATION.md
@.planning/phases/01-signal-core-infrastructure/01-01-SUMMARY.md
@.planning/phases/01-signal-core-infrastructure/01-02-SUMMARY.md
@.planning/phases/01-signal-core-infrastructure/01-03-SUMMARY.md
@src/daemon/service.py
@src/signal/client.py
@src/signal/queue.py
</context>

<tasks>

<task type="auto">
  <name>Wire message receiving loop in daemon</name>
  <files>src/daemon/service.py</files>
  <action>
Add async message receiving loop to ServiceDaemon.run() method.

**Current state (from VERIFICATION.md):**
- Line 145: Creates `queue_task` to process outgoing messages
- Line 147-150: Gathers tasks and runs until complete
- **MISSING:** No code creates task to receive incoming messages

**What to add (after line 145, before gathering tasks):**

```python
# Start message receiving loop
async def receive_loop():
    """Continuously receive messages from Signal and put them in queue."""
    try:
        async for message in self.signal_client.receive_messages():
            await self.message_queue.put(message)
            self.logger.info(
                "message_received_enqueued",
                sender=message.get("source"),
                timestamp=message.get("timestamp")
            )
    except Exception as e:
        self.logger.error("receive_loop_error", error=str(e))
        raise

receive_task = asyncio.create_task(receive_loop())
```

**Then modify line 147** to gather both tasks:
```python
await asyncio.gather(queue_task, receive_task)
```

**Why this fixes the gap:**
- `receive_messages()` already exists in SignalClient (136 lines, verified)
- `message_queue.put()` already exists in MessageQueue (143 lines, verified)
- This 15-line addition connects them: Signal API → receive_messages() → put() → queue
- Creates the missing ingestion pipeline identified in VERIFICATION.md

**What to avoid:**
- DON'T add command processing logic yet (that's Phase 3 - Claude integration)
- DON'T modify the existing queue_task (already working for outgoing messages)
- DON'T add error recovery beyond basic logging (connection resilience is Phase 7)
  </action>
  <verify>
1. `python -m pytest tests/test_daemon.py::test_message_receiving_loop -v` passes
2. Code inspection shows `receive_task` created alongside `queue_task`
3. `asyncio.gather()` includes both queue_task and receive_task
4. No syntax errors: `python -m py_compile src/daemon/service.py`
  </verify>
  <done>
- ServiceDaemon.run() creates async task for message receiving
- receive_loop() calls signal_client.receive_messages() continuously
- Received messages flow into message_queue via put()
- Both tasks (receive_task, queue_task) run concurrently via gather()
  </done>
</task>

<task type="auto">
  <name>Add integration test for message flow</name>
  <files>tests/test_daemon.py</files>
  <action>
Create integration test proving message flow: Signal API → daemon → queue.

**Add to tests/test_daemon.py:**

```python
@pytest.mark.asyncio
async def test_message_receiving_loop():
    """
    Integration test: Verify daemon receives messages from Signal
    and enqueues them for processing.

    Gap being closed: VERIFICATION.md identified that receive_messages()
    was never called by daemon. This test proves the wiring is complete.
    """
    # Mock Signal message payload
    mock_message = {
        "envelope": {
            "source": "+15551234567",
            "sourceNumber": "+15551234567",
            "timestamp": 1234567890000,
            "dataMessage": {
                "timestamp": 1234567890000,
                "message": "test command"
            }
        }
    }

    # Create daemon with mocked SignalClient
    class MockSignalClient:
        async def connect(self):
            pass

        async def disconnect(self):
            pass

        async def receive_messages(self):
            """Yield one test message then stop."""
            yield mock_message
            # Exit after one message to prevent infinite loop
            await asyncio.sleep(0.1)

        async def send_message(self, to_number, message):
            pass

    daemon = ServiceDaemon()
    daemon.signal_client = MockSignalClient()

    # Run daemon for short duration
    async def run_briefly():
        try:
            async with asyncio.timeout(0.5):
                await daemon.run()
        except asyncio.TimeoutError:
            pass  # Expected - daemon runs forever, we stop it with timeout

    await run_briefly()

    # Verify message was enqueued
    assert daemon.message_queue.qsize() > 0, "Message should be in queue"

    # Verify it's the message we sent
    queued_msg = await daemon.message_queue.get()
    assert queued_msg["envelope"]["source"] == "+15551234567"
    assert queued_msg["envelope"]["dataMessage"]["message"] == "test command"
```

**Why this test matters:**
- VERIFICATION.md identified gap: "No integration test showing message flow from Signal API → daemon → queue"
- This test proves the wiring exists end-to-end
- Mocking avoids need for real Signal API during testing
- Uses asyncio.timeout to cleanly stop the infinite daemon loop

**What to avoid:**
- DON'T test command processing logic (that's Phase 3)
- DON'T test phone verification in this test (already covered by test_auth.py)
- DON'T require real Signal API or Docker container running
  </action>
  <verify>
1. `python -m pytest tests/test_daemon.py::test_message_receiving_loop -v` passes
2. Test output shows message enqueued successfully
3. Coverage report shows daemon receive loop executed
  </verify>
  <done>
- Integration test exists proving Signal → daemon → queue flow
- Test uses mocked SignalClient to avoid external dependencies
- Test verifies message arrives in queue with correct data
- All tests pass (existing tests + new integration test)
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -m pytest tests/test_daemon.py -v` passes (all tests including new integration test)
- [ ] Code inspection confirms receive_task created in ServiceDaemon.run()
- [ ] Code inspection confirms asyncio.gather() runs both queue_task and receive_task
- [ ] No Python syntax errors or import issues
- [ ] Gap from VERIFICATION.md addressed: daemon now calls receive_messages()
</verification>

<success_criteria>
- All tasks completed
- Integration test proves message flow from Signal API to queue
- Daemon creates both receive_task and queue_task concurrently
- VERIFICATION.md gap "Daemon never calls receive_messages()" is CLOSED
- No errors or warnings introduced
</success_criteria>

<output>
After completion, create `.planning/phases/01-signal-core-infrastructure/01-04-SUMMARY.md`
</output>
