---
phase: 01-signal-core-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/signal/queue.py
  - src/signal/rate_limiter.py
  - src/signal/client.py
  - tests/test_queue.py
  - tests/test_rate_limiter.py
autonomous: true

must_haves:
  truths:
    - Message queue buffers incoming messages without blocking
    - Rate limiter prevents bursts exceeding Signal API limits
    - Exponential backoff activates when rate limits approached
    - Messages process in FIFO order
  artifacts:
    - path: src/signal/queue.py
      provides: Message queue with asyncio.Queue
      exports: [MessageQueue]
      min_lines: 40
    - path: src/signal/rate_limiter.py
      provides: Rate limiting with exponential backoff
      exports: [RateLimiter]
      min_lines: 30
    - path: tests/test_queue.py
      provides: Queue behavior tests
      min_lines: 20
  key_links:
    - from: src/signal/queue.py
      to: src/signal/client.py
      via: async message processing
      pattern: "async.*process"
    - from: src/signal/rate_limiter.py
      to: Signal API calls
      via: delay injection before send
      pattern: "await.*sleep"
---

<objective>
Implement message queue with rate limiting to prevent Signal API rate limit errors during message bursts.

Purpose: Signal API has rate limits (unknown exact limits, so defensive buffering required). Queue ensures reliable message delivery even when mobile sends multiple commands rapidly.
Output: Production-ready message queue with rate limiter protecting against burst traffic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning-signal/SIGNAL-PROJECT.md
@.planning-signal/SIGNAL-ROADMAP.md
@.planning-signal/research/SIGNAL-PITFALLS.md - Signal API rate limiting pitfalls
@.planning-signal/SIGNAL-REQUIREMENTS.md - INFRA-04 requirement
@.planning-signal/phases/01-signal-core-infrastructure/01-01-SUMMARY.md - SignalClient foundation
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement message queue with asyncio</name>
  <files>src/signal/queue.py</files>
  <action>
    Create src/signal/queue.py with MessageQueue class:
    - Use asyncio.Queue for async-safe message buffering
    - Implement put(message) method for adding messages to queue
    - Implement process_queue() async method that runs continuously
    - Ensure FIFO ordering (queue.get() processes oldest first)
    - Include queue size monitoring (warn if queue exceeds 100 messages)
    - Handle queue overflow gracefully (max size 1000, drop oldest if full)

    Use asyncio patterns from research/ARCHITECTURE.md. DO NOT use threading.Queue (not async-safe).
  </action>
  <verify>python -c "from src.signal.queue import MessageQueue; import asyncio; asyncio.run(MessageQueue().put('test'))" runs without errors</verify>
  <done>MessageQueue class implemented with async put/process methods</done>
</task>

<task type="auto">
  <name>Task 2: Implement rate limiter with exponential backoff</name>
  <files>src/signal/rate_limiter.py</files>
  <action>
    Create src/signal/rate_limiter.py with RateLimiter class:
    - Track message send rate (messages per minute)
    - Implement conservative limit: 30 messages/minute (0.5 msg/sec average)
    - Use token bucket algorithm for burst allowance (up to 5 messages instantly)
    - Implement exponential backoff: 1s, 2s, 4s, 8s, 16s (max 16s delay)
    - Reset backoff on successful send after cool-down period (60s)

    Conservative limits prevent hitting unknown Signal API rate limits. Research from pitfalls suggests being defensive.
  </action>
  <verify>python -c "from src.signal.rate_limiter import RateLimiter; r = RateLimiter(); print(r.can_send())" runs and returns True</verify>
  <done>RateLimiter class implemented with token bucket and exponential backoff</done>
</task>

<task type="auto">
  <name>Task 3: Integrate rate limiter with SignalClient</name>
  <files>src/signal/client.py</files>
  <action>
    Modify SignalClient class from Plan 01:
    - Add RateLimiter instance as class attribute
    - Update send_message() to check rate limiter before sending
    - Inject delay if rate limiter returns backoff time
    - Log rate limit events with structlog (info level for delays, warn for backoff)

    DO NOT break existing send/receive methods from Plan 01. Only add rate limiting to outgoing messages.
  </action>
  <verify>python -c "from src.signal.client import SignalClient; c = SignalClient()" creates client with rate limiter, no import errors</verify>
  <done>SignalClient rate-limited with exponential backoff on sends</done>
</task>

<task type="auto">
  <name>Task 4: Add unit tests for queue and rate limiter</name>
  <files>tests/test_queue.py, tests/test_rate_limiter.py</files>
  <action>
    Create tests/test_queue.py:
    - Test FIFO ordering: put messages A,B,C → process in order A,B,C
    - Test queue overflow: fill to max → oldest messages dropped
    - Test async behavior: multiple puts don't block each other

    Create tests/test_rate_limiter.py:
    - Test token bucket: 5 instant sends allowed, 6th delayed
    - Test exponential backoff: rapid sends trigger 1s, 2s, 4s delays
    - Test backoff reset: after cooldown, backoff resets to 1s

    Use pytest with pytest-asyncio. Follow research/STACK.md testing patterns.
  </action>
  <verify>pytest tests/test_queue.py tests/test_rate_limiter.py -v shows all tests passing</verify>
  <done>Unit tests validate queue FIFO behavior and rate limiter backoff logic</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] pytest tests/ passes with 100% test success
- [ ] Queue handles 100 rapid messages without errors
- [ ] Rate limiter delays 6th consecutive message (after 5 instant burst)
- [ ] Logs show rate limit events in structured format
</verification>

<success_criteria>
- MessageQueue implemented with asyncio.Queue and FIFO ordering
- RateLimiter implemented with token bucket and exponential backoff
- SignalClient integrated with rate limiting on outgoing messages
- All unit tests passing
- No rate limit errors possible from burst traffic
- Ready for daemon management (Plan 03)
</success_criteria>

<output>
After completion, create `.planning-signal/phases/01-signal-core-infrastructure/01-02-SUMMARY.md`
</output>
