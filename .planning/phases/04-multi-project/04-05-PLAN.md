---
phase: 04-multi-project
plan: 05
type: execute
wave: 5
depends_on: ["04-01", "04-03"]
files_modified: [src/daemon/service.py, tests/test_daemon.py]
autonomous: true

must_haves:
  truths:
    - "Thread mappings load on daemon startup"
    - "Daemon doesn't crash if thread_mappings.db doesn't exist"
    - "Daemon logs thread mapping count on startup"
  artifacts:
    - path: "src/daemon/service.py"
      provides: "ThreadMapper initialization in daemon lifecycle"
      contains: "await self.thread_mapper.initialize()"
    - path: "tests/test_daemon.py"
      provides: "Tests for daemon startup with thread mappings"
      min_lines: 30
  key_links:
    - from: "SignalBot.start()"
      to: "ThreadMapper.initialize()"
      via: "Daemon startup sequence"
      pattern: "await self\\.thread_mapper\\.initialize\\(\\)"
---

<objective>
Ensure thread mappings are loaded and available when daemon starts.

Purpose: Complete the persistence story - thread mappings must survive daemon restarts by loading from SQLite on startup.

Output: Daemon startup sequence initializes ThreadMapper alongside SessionManager, with proper error handling and logging.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior work
@.planning/phases/04-multi-project/04-01-SUMMARY.md
@.planning/phases/04-multi-project/04-03-SUMMARY.md
@.planning/phases/02-session-management-durable-execution/02-04-SUMMARY.md
@.planning/phases/02-session-management-durable-execution/02-06-SUMMARY.md

# Existing architecture
@src/daemon/service.py

## Key Context from Plans 04-01, 04-03, Phase 2-4, and Phase 2-6

**What exists:**
- ThreadMapper.initialize(): Creates tables, enables WAL mode (Plan 04-01)
- ThreadMapper already added to daemon __init__ (Plan 04-03)
- SessionManager.initialize() pattern (Phase 2-4)
- CrashRecovery runs on daemon startup (Phase 2-4)

**Current daemon startup sequence (from Plan 04-03):**
```python
async def start(self):
    logger.info("Starting Signal bot daemon...")

    # Initialize managers
    await self.manager.initialize()
    await self.thread_mapper.initialize()  # Already added in 04-03

    # Create ThreadCommands
    self.thread_commands = ThreadCommands(self.thread_mapper)

    # Recovery and session commands...
```

**Verification needed:**
Plan 04-03 added thread_mapper.initialize() but no tests verify:
1. Daemon starts successfully with thread mappings
2. Daemon handles missing thread_mappings.db gracefully
3. Thread mappings are logged on startup

**Phase 2-4 crash recovery pattern:**
```python
crashed_sessions = await self.recovery.detect_crashed_sessions()
if crashed_sessions:
    logger.warning(f"Detected {len(crashed_sessions)} crashed sessions")
    await self.recovery.recover(crashed_sessions)
```

**Similar pattern needed for thread mappings:**
```python
mappings = await self.thread_mapper.list_all()
logger.info(f"Loaded {len(mappings)} thread mappings")
```

**Error handling:**
ThreadMapper.initialize() creates tables if they don't exist (like SessionManager), so:
- First daemon start: thread_mappings.db doesn't exist → created
- Subsequent starts: thread_mappings.db exists → loaded
- Both cases should work without errors
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify ThreadMapper initialization in startup</name>
  <files>src/daemon/service.py</files>
  <action>
    Verify thread_mapper.initialize() is already in SignalBot.start() from Plan 04-03.

    If not present, add after manager.initialize():
    ```python
    async def start(self):
        logger.info("Starting Signal bot daemon...")

        # Initialize managers
        await self.manager.initialize()
        await self.thread_mapper.initialize()  # Should already be here
    ```

    This task is primarily verification. Plan 04-03 should have added this.
  </action>
  <verify>
    - src/daemon/service.py contains "await self.thread_mapper.initialize()"
    - Called after await self.manager.initialize()
  </verify>
  <done>ThreadMapper initialization confirmed in daemon startup</done>
</task>

<task type="auto">
  <name>Task 2: Add thread mapping startup logging</name>
  <files>src/daemon/service.py</files>
  <action>
    Add logging for thread mappings after initialization in SignalBot.start():
    ```python
    # After thread_mapper.initialize()
    await self.thread_mapper.initialize()

    # Load and log thread mappings
    mappings = await self.thread_mapper.list_all()
    if mappings:
        logger.info(
            f"Loaded {len(mappings)} thread mapping(s)",
            thread_count=len(mappings)
        )
    else:
        logger.info("No thread mappings configured")
    ```

    Follow Phase 2-4 crash recovery logging pattern:
    - Informational level (logger.info)
    - Count of items loaded
    - Structured logging with extra fields (thread_count)
    - User-friendly message
  </action>
  <verify>
    - Daemon logs thread mapping count on startup
    - Log message appears after "Starting Signal bot daemon..."
    - Uses structlog format with thread_count field
  </verify>
  <done>Thread mapping count logged on daemon startup</done>
</task>

<task type="auto">
  <name>Task 3: Add daemon startup tests with thread mappings</name>
  <files>tests/test_daemon.py</files>
  <action>
    Add tests for daemon startup with thread mappings:
    ```python
    async def test_daemon_start_with_thread_mappings():
        """
        Daemon loads existing thread mappings on startup
        """
        # Setup: Create daemon with thread_mappings.db containing 2 mappings
        # Start daemon
        # Verify: thread_mapper.list_all() returns 2 mappings
        # Verify: Logs show "Loaded 2 thread mapping(s)"

    async def test_daemon_start_no_thread_mappings():
        """
        Daemon starts successfully when thread_mappings.db is empty
        """
        # Setup: Create daemon with empty thread_mappings.db
        # Start daemon
        # Verify: thread_mapper.list_all() returns []
        # Verify: Logs show "No thread mappings configured"

    async def test_daemon_start_creates_thread_mappings_db():
        """
        Daemon creates thread_mappings.db on first start
        """
        # Setup: Create daemon, ensure thread_mappings.db doesn't exist
        # Start daemon
        # Verify: thread_mappings.db file created
        # Verify: thread_mapper.list_all() works (returns [])
    ```

    Follow existing test_daemon.py patterns:
    - Use pytest-asyncio
    - Mock dependencies (SessionManager, signal_client)
    - Use temporary directories for database files
    - Test both success cases and edge cases
    - Verify log output with caplog fixture
  </action>
  <verify>
    Run: pytest tests/test_daemon.py -k thread
    Result: All thread mapping startup tests pass
  </verify>
  <done>Daemon startup tests cover thread mapping initialization</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] thread_mapper.initialize() called in daemon startup
- [ ] Thread mapping count logged on startup
- [ ] Daemon handles missing thread_mappings.db gracefully
- [ ] Daemon handles empty thread_mappings.db gracefully
- [ ] Daemon tests verify thread mapping initialization
- [ ] No new test failures introduced
</verification>

<success_criteria>
- All tasks completed
- Thread mappings persist across daemon restarts
- Daemon startup robust to all thread mapping states (missing, empty, populated)
- Clear logging provides visibility into thread mapping state
- Full test coverage for daemon startup with thread mappings
</success_criteria>

<output>
After completion, create `.planning/phases/04-multi-project/04-05-SUMMARY.md`
</output>
