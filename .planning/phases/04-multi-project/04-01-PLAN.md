---
phase: 04-multi-project
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/thread/__init__.py, src/thread/mapper.py, src/thread/schema.sql, tests/test_thread_mapper.py]
autonomous: true

must_haves:
  truths:
    - "System stores thread-to-project mappings persistently in SQLite"
    - "Each thread maps to exactly one project directory"
    - "Mappings survive daemon restarts"
    - "Invalid mappings (non-existent paths, duplicates) are rejected"
  artifacts:
    - path: "src/thread/mapper.py"
      provides: "ThreadMapper with CRUD operations for thread-project mappings"
      min_lines: 100
      exports: ["ThreadMapper", "ThreadMappingError"]
    - path: "src/thread/schema.sql"
      provides: "SQLite schema for thread_mappings table"
      contains: "CREATE TABLE IF NOT EXISTS thread_mappings"
    - path: "tests/test_thread_mapper.py"
      provides: "TDD test suite for ThreadMapper"
      min_lines: 80
  key_links:
    - from: "ThreadMapper"
      to: "SQLite database"
      via: "aiosqlite async queries"
      pattern: "INSERT INTO thread_mappings|SELECT .* FROM thread_mappings"
    - from: "ThreadMapper.map()"
      to: "Path validation"
      via: "Path.exists() check before storing"
      pattern: "Path.*\\.exists\\(\\)"
---

<objective>
Create persistent storage for Signal thread to project directory mappings.

Purpose: Enable multi-project support by maintaining bijective mappings between Signal threads and project paths that survive daemon restarts.

Output: ThreadMapper class with SQLite persistence for thread-project associations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior work
@.planning/phases/02-session-management-durable-execution/02-01-SUMMARY.md
@.planning/phases/03-claude-integration/03-04-SUMMARY.md

# Existing architecture
@src/session/manager.py
@src/session/schema.sql
@src/session/commands.py

## Key Context from Phase 2-3

**What exists:**
- SessionManager: SQLite-backed session persistence with aiosqlite
- Session model: Includes thread_id field (already stored but not validated)
- SessionCommands: Has in-memory thread_sessions dict (thread_id → session_id)
- Index: idx_sessions_thread_id exists for thread_id lookups

**Pattern to follow:**
Phase 2-1 established the pattern:
- TDD RED-GREEN-REFACTOR cycle
- SQLite with WAL mode for concurrent access
- aiosqlite for async database operations
- UUID4 for IDs
- UTC-aware timestamps with datetime.now(UTC)
- Comprehensive test coverage

**Architecture decision (from STATE.md):**
"Thread-to-session mapping" - track which Signal thread has which active session, enables stateful conversations without specifying session ID every time.

**Current limitation:**
SessionCommands.thread_sessions is a dict[str, str] that's only in memory. Lost on daemon restart. Phase 4 needs persistent storage.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create thread mapping schema (SQL)</name>
  <files>src/thread/schema.sql, src/thread/__init__.py</files>
  <action>
    Create src/thread/schema.sql with thread_mappings table:
    - thread_id TEXT PRIMARY KEY (Signal thread identifier)
    - project_path TEXT UNIQUE NOT NULL (local directory path)
    - created_at TEXT NOT NULL (UTC timestamp when mapped)
    - updated_at TEXT NOT NULL (UTC timestamp when last modified)

    Add idx_thread_mappings_path index on project_path for reverse lookups.

    Create src/thread/__init__.py with exports: ["ThreadMapper", "ThreadMappingError"]

    Follow Phase 2-1 pattern: simple schema, UTC timestamps, indexes for performance.
  </action>
  <verify>
    - src/thread/schema.sql exists with CREATE TABLE statement
    - Schema has PRIMARY KEY on thread_id
    - Schema has UNIQUE constraint on project_path (bijection enforcement)
    - src/thread/__init__.py exists with exports
  </verify>
  <done>Thread mapping schema defined following Phase 2 patterns</done>
</task>

<task type="auto">
  <name>Task 2: TDD - Write failing tests for ThreadMapper</name>
  <files>tests/test_thread_mapper.py</files>
  <action>
    RED phase: Write failing tests for ThreadMapper class that doesn't exist yet.

    Test cases:
    1. test_map_creates_new_mapping() - map(thread_id, valid_path) succeeds
    2. test_map_rejects_nonexistent_path() - raises ThreadMappingError if path doesn't exist
    3. test_map_rejects_duplicate_thread() - raises ThreadMappingError if thread already mapped
    4. test_map_rejects_duplicate_path() - raises ThreadMappingError if path already mapped to different thread
    5. test_get_by_thread() - retrieves mapping by thread_id
    6. test_get_by_path() - retrieves mapping by project_path (reverse lookup)
    7. test_list_all() - returns all mappings
    8. test_unmap_removes_mapping() - unmap(thread_id) removes mapping
    9. test_unmap_nonexistent_noop() - unmap() on non-existent thread doesn't error (idempotent)

    Follow Phase 2-1 TDD pattern:
    - pytest with pytest-asyncio
    - Fixtures for temp database, mock paths
    - Async test functions (async def test_*)
    - Use aiosqlite for database operations

    Tests MUST fail because ThreadMapper doesn't exist yet.
  </action>
  <verify>
    Run: pytest tests/test_thread_mapper.py
    Result: All tests fail with "ThreadMapper not found" or similar import errors
  </verify>
  <done>Comprehensive failing test suite written</done>
</task>

<task type="auto">
  <name>Task 3: TDD - Implement ThreadMapper to pass tests</name>
  <files>src/thread/mapper.py</files>
  <action>
    GREEN phase: Implement ThreadMapper class to make tests pass.

    Class structure:
    ```python
    class ThreadMappingError(Exception):
        """Raised when thread mapping operation fails."""
        pass

    @dataclass
    class ThreadMapping:
        thread_id: str
        project_path: str
        created_at: datetime
        updated_at: datetime

    class ThreadMapper:
        def __init__(self, db_path: str):
            # Store db_path, initialize in async init

        async def initialize(self):
            # Create tables, enable WAL mode (Phase 2-1 pattern)

        async def map(self, thread_id: str, project_path: str) -> ThreadMapping:
            # Validate: Path.exists() check
            # Validate: No existing mapping for thread_id
            # Validate: No existing mapping for project_path
            # INSERT thread mapping
            # Return ThreadMapping

        async def get_by_thread(self, thread_id: str) -> ThreadMapping | None:
            # SELECT by thread_id, return ThreadMapping or None

        async def get_by_path(self, project_path: str) -> ThreadMapping | None:
            # SELECT by project_path (reverse lookup)

        async def list_all(self) -> list[ThreadMapping]:
            # SELECT * ordered by created_at DESC

        async def unmap(self, thread_id: str) -> None:
            # DELETE by thread_id (idempotent - no error if doesn't exist)
    ```

    Follow Phase 2-1 patterns:
    - aiosqlite for async SQLite
    - WAL mode: PRAGMA journal_mode=WAL
    - UTC timestamps: datetime.now(UTC)
    - Path validation with pathlib.Path
    - ThreadMappingError for validation failures
    - Idempotent operations (unmap doesn't fail if not exists)
  </action>
  <verify>
    Run: pytest tests/test_thread_mapper.py
    Result: All tests pass
  </verify>
  <done>ThreadMapper implemented with full TDD coverage</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All TDD tests pass (pytest tests/test_thread_mapper.py)
- [ ] ThreadMapper class exists with all CRUD methods
- [ ] ThreadMapping dataclass exists
- [ ] ThreadMappingError exception exists
- [ ] SQLite schema created with proper indexes
- [ ] Path validation prevents invalid mappings
- [ ] Bijection enforced (one thread → one path, one path → one thread)
</verification>

<success_criteria>
- All tasks completed
- Full TDD test suite passing
- ThreadMapper ready for integration in Plan 02
- No new test failures introduced
- Thread mapping persistence matches Phase 2 session persistence patterns
</success_criteria>

<output>
After completion, create `.planning/phases/04-multi-project/04-01-SUMMARY.md`
</output>
