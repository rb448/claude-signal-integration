---
phase: 04-multi-project
plan: 03
type: execute
wave: 3
depends_on: ["04-01", "04-02"]
files_modified: [src/session/commands.py, src/daemon/service.py, tests/test_session_commands.py]
autonomous: true

must_haves:
  truths:
    - "SessionCommands routes /thread commands to ThreadCommands"
    - "Daemon initializes ThreadMapper and ThreadCommands on startup"
    - "/thread commands work end-to-end from Signal"
    - "Thread mappings are used when starting new sessions"
  artifacts:
    - path: "src/session/commands.py"
      provides: "Integrated thread command routing"
      contains: "self.thread_commands"
    - path: "src/daemon/service.py"
      provides: "ThreadMapper and ThreadCommands initialization"
      contains: "ThreadMapper|ThreadCommands"
    - path: "tests/test_session_commands.py"
      provides: "Integration tests for thread command routing"
      contains: "/thread"
  key_links:
    - from: "SessionCommands.handle()"
      to: "ThreadCommands.handle()"
      via: "message.startswith('/thread')"
      pattern: "if.*startswith.*['\\\"]\/thread['\\\"]"
    - from: "SignalBot._handle_message()"
      to: "SessionCommands.handle()"
      via: "daemon service layer"
---

<objective>
Integrate ThreadMapper and ThreadCommands into daemon and session management.

Purpose: Wire thread management into the running system so users can manage thread-project mappings from Signal and have them persist across restarts.

Output: End-to-end integration from Signal → ThreadCommands → ThreadMapper → SQLite, with daemon initialization and session command routing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior work
@.planning/phases/04-multi-project/04-01-SUMMARY.md
@.planning/phases/04-multi-project/04-02-SUMMARY.md
@.planning/phases/02-session-management-durable-execution/02-05-SUMMARY.md
@.planning/phases/02-session-management-durable-execution/02-06-SUMMARY.md

# Existing architecture
@src/daemon/service.py
@src/session/commands.py

## Key Context from Plans 04-01, 04-02, Phase 2-5, and Phase 2-6

**What exists:**
- ThreadMapper: Persistent thread → project storage (Plan 04-01)
- ThreadCommands: User-facing /thread commands (Plan 04-02)
- SessionCommands: Command routing with /session (Phase 2-5)
- SignalBot: Message handling in daemon (Phase 2-6)

**Integration pattern from Phase 2-5:**
SessionCommands was integrated into daemon by:
1. Daemon initializes SessionManager, CrashRecovery, SessionCommands
2. SignalBot routes messages to SessionCommands.handle()
3. SessionCommands routes to /session or Claude commands

**Current routing in SessionCommands.handle():**
```python
async def handle(self, thread_id: str, message: str) -> str:
    if message.startswith("/session"):
        return await self._handle_session_command(thread_id, message)
    else:
        return await self._handle_claude_command(thread_id, message)
```

**New routing needed:**
```python
async def handle(self, thread_id: str, message: str) -> str:
    if message.startswith("/thread"):
        return await self.thread_commands.handle(thread_id, message)
    elif message.startswith("/session"):
        return await self._handle_session_command(thread_id, message)
    else:
        return await self._handle_claude_command(thread_id, message)
```

**Daemon initialization pattern (from Phase 2-5):**
```python
# In SignalBot.__init__():
self.manager = SessionManager(db_path)
self.recovery = CrashRecovery(self.manager, lifecycle)
self.commands = SessionCommands(self.manager, lifecycle, ...)
```

**Persistence location:**
Sessions stored in: ~/Library/Application Support/claude-signal-bot/sessions.db
Thread mappings should use: ~/Library/Application Support/claude-signal-bot/thread_mappings.db
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize ThreadMapper and ThreadCommands in daemon</name>
  <files>src/daemon/service.py</files>
  <action>
    Modify SignalBot.__init__() to initialize ThreadMapper and ThreadCommands.

    Add after SessionManager initialization:
    ```python
    # Thread mapping initialization
    thread_db_path = data_dir / "thread_mappings.db"
    self.thread_mapper = ThreadMapper(str(thread_db_path))

    # Must initialize in async start() method
    # self.thread_commands will be set there
    ```

    Modify SignalBot.start() to initialize ThreadMapper:
    ```python
    async def start(self):
        logger.info("Starting Signal bot daemon...")

        # Initialize managers
        await self.manager.initialize()
        await self.thread_mapper.initialize()  # NEW

        # Create ThreadCommands (requires initialized mapper)
        self.thread_commands = ThreadCommands(self.thread_mapper)  # NEW

        # Existing recovery and commands initialization...
    ```

    Follow Phase 2-5 pattern:
    - ThreadMapper created in __init__ with path
    - ThreadMapper.initialize() called in async start()
    - ThreadCommands created after initialization
    - data_dir from existing pattern (~/.local/share/claude-signal-bot or ~/Library/Application Support)
  </action>
  <verify>
    - ThreadMapper initialization added to SignalBot.start()
    - ThreadCommands created after mapper.initialize()
    - thread_mappings.db path uses same data_dir pattern as sessions.db
  </verify>
  <done>ThreadMapper and ThreadCommands initialized in daemon</done>
</task>

<task type="auto">
  <name>Task 2: Wire ThreadCommands into SessionCommands routing</name>
  <files>src/session/commands.py, tests/test_session_commands.py</files>
  <action>
    Modify SessionCommands to route /thread commands to ThreadCommands.

    Update __init__:
    ```python
    def __init__(
        self,
        manager: SessionManager,
        lifecycle: SessionLifecycle,
        process_factory: Callable[..., ClaudeProcess],
        orchestrator: ClaudeOrchestrator | None = None,
        thread_commands: ThreadCommands | None = None  # NEW
    ):
        self.manager = manager
        self.lifecycle = lifecycle
        self.process_factory = process_factory
        self.orchestrator = orchestrator
        self.thread_commands = thread_commands  # NEW
        self.processes: dict[str, ClaudeProcess] = {}
        self.thread_sessions: dict[str, str] = {}
    ```

    Update handle() to route /thread commands:
    ```python
    async def handle(self, thread_id: str, message: str) -> str | None:
        # Route to appropriate handler
        if message.startswith("/thread"):
            # New: delegate to ThreadCommands
            if self.thread_commands:
                return await self.thread_commands.handle(thread_id, message)
            else:
                return "Thread management not available."
        elif message.startswith("/session"):
            return await self._handle_session_command(thread_id, message)
        else:
            return await self._handle_claude_command(thread_id, message)
    ```

    Add integration tests in tests/test_session_commands.py:
    - test_handle_routes_thread_commands()
    - test_handle_thread_commands_unavailable()

    Follow Phase 2-5 pattern:
    - Optional parameter (thread_commands: ThreadCommands | None)
    - Graceful degradation if not provided
    - Clear delegation to specialized handler
  </action>
  <verify>
    Run: pytest tests/test_session_commands.py -k thread
    Result: Thread command routing tests pass
  </verify>
  <done>SessionCommands routes /thread commands to ThreadCommands</done>
</task>

<task type="auto">
  <name>Task 3: Pass ThreadCommands to SessionCommands in daemon</name>
  <files>src/daemon/service.py</files>
  <action>
    Update SessionCommands initialization in SignalBot.start() to pass thread_commands.

    Modify after ThreadCommands creation:
    ```python
    # Session commands (updated with thread_commands)
    self.commands = SessionCommands(
        self.manager,
        lifecycle,
        lambda project_path, session_id: ClaudeProcess(project_path, session_id),
        orchestrator=self.orchestrator,
        thread_commands=self.thread_commands  # NEW
    )
    ```

    This completes the wiring:
    SignalBot → SessionCommands → ThreadCommands → ThreadMapper → SQLite

    Follow Phase 2-6 pattern: daemon owns all components, passes them to SessionCommands.
  </action>
  <verify>
    - SessionCommands created with thread_commands parameter
    - End-to-end flow wired: Signal → SessionCommands → ThreadCommands → ThreadMapper
  </verify>
  <done>ThreadCommands fully integrated into daemon architecture</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] ThreadMapper initialized in daemon start()
- [ ] ThreadCommands created after mapper initialization
- [ ] SessionCommands routes /thread messages to ThreadCommands
- [ ] SessionCommands receives thread_commands in constructor
- [ ] Integration tests pass for thread command routing
- [ ] No new test failures introduced
</verification>

<success_criteria>
- All tasks completed
- ThreadCommands fully wired into daemon
- /thread commands routable from Signal
- Thread mappings persist in thread_mappings.db
- Ready for Plan 04 to add project validation logic
</success_criteria>

<output>
After completion, create `.planning/phases/04-multi-project/04-03-SUMMARY.md`
</output>
