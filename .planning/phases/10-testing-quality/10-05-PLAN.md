---
phase: 10-testing-quality
plan: 05
type: execute
wave: 3
depends_on: ["10-01"]
files_modified:
  - tests/unit/test_missing_coverage.py
  - tests/security/test_injection_prevention.py
  - tests/security/test_auth_boundary.py
autonomous: true

must_haves:
  truths:
    - "All modules identified in 10-01 audit as below 80% coverage reach threshold"
    - "Security tests validate input sanitization and auth boundaries"
    - "No SQL injection, command injection, or path traversal vulnerabilities"
    - "Phone number authorization enforced at all entry points"
  artifacts:
    - path: "tests/unit/test_missing_coverage.py"
      provides: "Retroactive unit tests for coverage gaps"
      min_lines: 100
      contains: "def test_"
    - path: "tests/security/test_injection_prevention.py"
      provides: "Security tests for injection attacks"
      min_lines: 60
      exports: ["test_sql_injection", "test_command_injection", "test_path_traversal"]
    - path: "tests/security/test_auth_boundary.py"
      provides: "Authorization boundary tests"
      min_lines: 50
      exports: ["test_unauthorized_phone_blocked", "test_authorized_phone_allowed"]
  key_links:
    - from: "test_injection_prevention.py"
      to: "src/daemon/service.py + src/session/manager.py"
      via: "malicious input payloads"
      pattern: "malicious.*payload"
    - from: "test_auth_boundary.py"
      to: "src/auth/phone_verifier.py"
      via: "phone number validation"
      pattern: "phone_verifier.*is_authorized"
---

<objective>
Address coverage gaps and security testing identified in TDD audit (Plan 10-01).

Purpose: Bring all modules to >80% coverage and ensure security boundaries are tested. Retroactive testing for components that didn't follow TDD during initial development.

Output: Additional unit tests closing coverage gaps and comprehensive security tests validating input sanitization and authorization.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-testing-quality/10-01-SUMMARY.md

# Phase 10 requirements this plan addresses:
# - TEST-01: All core components have unit tests with >80% coverage (close gaps)
# - Security testing from roadmap TDD strategy

# Coverage gaps will be identified by Plan 10-01 execution
# This plan is flexible - tasks will be refined based on 10-01 audit results
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement retroactive unit tests for coverage gaps</name>
  <files>tests/unit/test_missing_coverage.py</files>
  <action>
    Based on TEST-AUDIT.md from Plan 10-01, write retroactive tests for modules below 80%:
    1. Load coverage_report.txt to identify specific uncovered line ranges
    2. For each module below 80%, analyze uncovered lines to identify:
       - Edge cases not tested (empty input, null values, boundary conditions)
       - Error paths not tested (exception handling, validation failures)
       - Configuration branches not tested (feature flags, environment variations)
    3. Write targeted unit tests to cover these gaps:
       - Focus on highest-value coverage gains first
       - Prioritize critical paths (auth, session management, data persistence)
       - Use parametrized tests for multiple scenarios: `@pytest.mark.parametrize`
    4. Verify coverage improvement:
       - Run `pytest --cov=src --cov-report=term-missing` after adding tests
       - Confirm modules reach >80% threshold

    Example modules likely needing retroactive tests (based on typical patterns):
    - Configuration handling (config parsing, validation)
    - Error formatting and user messages
    - Edge cases in reconnection backoff calculation
    - Timeout handling in approval system

    This task is flexible - actual targets determined by 10-01 audit results.
  </action>
  <verify>
    - `pytest tests/unit/test_missing_coverage.py -v` passes
    - Re-run coverage report shows improvement
    - Modules previously below 80% now meet threshold
  </verify>
  <done>Retroactive unit tests close coverage gaps identified in audit</done>
</task>

<task type="auto">
  <name>Task 2: Implement SQL injection prevention tests</name>
  <files>tests/security/test_injection_prevention.py</files>
  <action>
    Create security tests for injection attack prevention:
    1. Create directory: `mkdir -p tests/security`
    2. `test_sql_injection_in_session_queries()`:
       - Attempt to create session with malicious path: `/path'; DROP TABLE sessions; --`
       - Verify SQLite parameterized queries prevent injection
       - Verify no table dropped, query fails safely
    3. `test_command_injection_in_bash_execution()`:
       - Simulate user sending malicious command: `$(rm -rf /)`
       - Verify asyncio.create_subprocess_exec prevents shell expansion
       - Verify args separated from command (no shell=True)
    4. `test_path_traversal_in_project_paths()`:
       - Attempt session creation with: `../../etc/passwd`
       - Verify path validation rejects traversal
       - Verify no access to files outside allowed project directories
    5. `test_message_payload_sanitization()`:
       - Send Signal message with: `<script>alert('XSS')</script>`
       - Verify output escaping when formatting for Signal
       - Verify no code execution in message handling

    Use actual components (SessionManager, ClaudeProcess) with malicious inputs.
  </action>
  <verify>
    - `pytest tests/security/test_injection_prevention.py -v` passes
    - All injection attempts safely blocked
    - No security warnings logged
  </verify>
  <done>Injection prevention validated for SQL, command, and path traversal attacks</done>
</task>

<task type="auto">
  <name>Task 3: Implement authorization boundary tests</name>
  <files>tests/security/test_auth_boundary.py</files>
  <action>
    Create tests validating phone number authorization:
    1. `test_unauthorized_phone_number_blocked()`:
       - Configure daemon with authorized phone: +15551234567
       - Send message from unauthorized phone: +15559999999
       - Verify PhoneVerifier.is_authorized() returns False
       - Verify message not processed (no session command execution)
       - Verify warning logged
    2. `test_authorized_phone_number_allowed()`:
       - Configure daemon with authorized phone: +15551234567
       - Send message from authorized phone: +15551234567
       - Verify PhoneVerifier.is_authorized() returns True
       - Verify message processed normally
    3. `test_e164_format_validation()`:
       - Test invalid formats rejected:
         - No country code: `5551234567`
         - Letters: `+1-555-ABCD`
         - Too short: `+1555`
       - Test valid E.164 formats accepted:
         - US: `+15551234567`
         - UK: `+447911123456`
    4. `test_authorization_bypass_attempts()`:
       - Attempt to spoof sender via message payload manipulation
       - Verify authorization checked on actual Signal API sender, not message content
       - Verify no bypass possible

    Use real PhoneVerifier with test config.
  </action>
  <verify>
    - `pytest tests/security/test_auth_boundary.py -v` passes
    - Authorization enforced at all entry points
    - Invalid phone formats rejected
  </verify>
  <done>Authorization boundary validated with phone number enforcement</done>
</task>

<task type="auto">
  <name>Task 4: Update TEST-AUDIT.md with final coverage report</name>
  <files>.planning/TEST-AUDIT.md</files>
  <action>
    Append final coverage summary to TEST-AUDIT.md:
    1. Re-run full test suite with coverage: `pytest --cov=src --cov-report=term-missing`
    2. Append "## Final Coverage Report" section:
       - Overall coverage percentage (target: >80%)
       - Module breakdown showing which reached threshold
       - Modules still below threshold with explanation (if any)
    3. Document security test results:
       - List security tests added
       - Injection attack coverage verified
       - Authorization boundary coverage verified
    4. Final summary:
       - Total test count (unit + integration + load + chaos + security)
       - Coverage improvement from baseline (Plan 10-01) to final
       - Remaining gaps (if any) with justification for deferral

    This becomes the final Phase 10 deliverable documenting testing quality achieved.
  </action>
  <verify>
    - TEST-AUDIT.md contains "## Final Coverage Report"
    - Coverage percentages documented
    - Security test results included
  </verify>
  <done>Final coverage report documents testing quality achieved in Phase 10</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pytest --cov=src --cov-report=term` shows >80% overall coverage
- [ ] Security tests pass and validate injection prevention
- [ ] Authorization tests verify phone number enforcement
- [ ] TEST-AUDIT.md updated with final coverage summary
</verification>

<success_criteria>
- All tasks completed
- Coverage gaps from 10-01 audit closed
- All core modules reach >80% coverage threshold
- Security tests validate injection prevention and auth boundaries
- Final coverage report documents quality achievement
- Phase 10 testing requirements fully satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/10-testing-quality/10-05-SUMMARY.md`
</output>
