---
phase: 03-claude-integration
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/session/commands.py
  - tests/test_session_commands.py
autonomous: true
gap_closure: true

# Goal-backward verification (from VERIFICATION.md)
must_haves:
  truths:
    - "Commands sent from Signal execute in Claude Code CLI"
    - "Claude responses stream back to Signal in real-time"
    - "All Claude Code commands work from Signal (command parity achieved)"
  artifacts:
    - path: "src/session/commands.py"
      provides: "Bridge wiring after session start/resume"
      contains: "self.orchestrator.bridge = process.get_bridge()"
    - path: "tests/test_session_commands.py"
      provides: "Test verifying bridge is set"
      exports: ["test_start_sets_orchestrator_bridge", "test_resume_sets_orchestrator_bridge"]
  key_links:
    - from: "SessionCommands._start()"
      to: "orchestrator.bridge"
      via: "self.orchestrator.bridge = process.get_bridge()"
      pattern: "self\\.orchestrator\\.bridge\\s*=\\s*process\\.get_bridge\\(\\)"
    - from: "SessionCommands._resume()"
      to: "orchestrator.bridge"
      via: "self.orchestrator.bridge = process.get_bridge()"
      pattern: "self\\.orchestrator\\.bridge\\s*=\\s*process\\.get_bridge\\(\\)"
---

<objective>
Fix critical wiring gap: set orchestrator.bridge after session start/resume

Purpose: Enable command execution - orchestrator needs bridge reference to send commands to Claude CLI
Output: Commands from Signal execute in Claude Code CLI, responses stream back
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Gap closure context
@.planning/phases/03-claude-integration/03-VERIFICATION.md

# What's already built
@.planning/phases/03-claude-integration/03-01-SUMMARY.md — CLIBridge for stdin/stdout
@.planning/phases/03-claude-integration/03-04-SUMMARY.md — ClaudeOrchestrator coordination

# Current implementation
@src/session/commands.py — SessionCommands with _start() and _resume()
@src/claude/process.py — ClaudeProcess with get_bridge() method
@src/claude/orchestrator.py — ClaudeOrchestrator expects bridge to be set
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire orchestrator bridge in SessionCommands._start()</name>
  <files>src/session/commands.py</files>
  <action>
After line 151 where process is started and stored:
```python
await process.start()
self.processes[session.id] = process
```

Add:
```python
# Wire orchestrator bridge so commands can execute
self.orchestrator.bridge = process.get_bridge()
```

This connects the orchestrator to the newly started Claude CLI process, enabling execute_command() to work.
  </action>
  <verify>Grep for "self.orchestrator.bridge = process.get_bridge()" in _start() method</verify>
  <done>Bridge is set after session start, orchestrator can execute commands</done>
</task>

<task type="auto">
  <name>Task 2: Wire orchestrator bridge in SessionCommands._resume()</name>
  <files>src/session/commands.py</files>
  <action>
After line 220 where process is started on resume and stored:
```python
await process.start(conversation_history=conversation_history)
self.processes[session_id] = process
```

Add:
```python
# Wire orchestrator bridge so commands can execute
self.orchestrator.bridge = process.get_bridge()
```

This connects the orchestrator to the resumed Claude CLI process, enabling execute_command() to work after resume.
  </action>
  <verify>Grep for "self.orchestrator.bridge = process.get_bridge()" in _resume() method</verify>
  <done>Bridge is set after session resume, orchestrator can execute commands</done>
</task>

<task type="auto">
  <name>Task 3: Add test verifying bridge is set after start</name>
  <files>tests/test_session_commands.py</files>
  <action>
Add test to verify orchestrator.bridge is set after _start():

```python
@pytest.mark.asyncio
async def test_start_sets_orchestrator_bridge(session_manager, orchestrator, signal_client):
    """Test that _start() wires orchestrator bridge to enable command execution."""
    commands = SessionCommands(session_manager, orchestrator, signal_client)

    # Create session
    session = await session_manager.create("+15551234567", "/Users/test/project")

    # Start session
    await commands._start(session)

    # Verify bridge is set (not None)
    assert orchestrator.bridge is not None, "orchestrator.bridge should be set after _start()"

    # Verify it's the process's bridge
    process = commands.processes[session.id]
    assert orchestrator.bridge is process.get_bridge(), "orchestrator.bridge should reference process bridge"
```

This test catches the gap if bridge is not set after start.
  </action>
  <verify>Test passes with pytest tests/test_session_commands.py::test_start_sets_orchestrator_bridge</verify>
  <done>Test verifies bridge is wired after start</done>
</task>

<task type="auto">
  <name>Task 4: Add test verifying bridge is set after resume</name>
  <files>tests/test_session_commands.py</files>
  <action>
Add test to verify orchestrator.bridge is set after _resume():

```python
@pytest.mark.asyncio
async def test_resume_sets_orchestrator_bridge(session_manager, orchestrator, signal_client):
    """Test that _resume() wires orchestrator bridge to enable command execution."""
    commands = SessionCommands(session_manager, orchestrator, signal_client)

    # Create and pause session
    session = await session_manager.create("+15551234567", "/Users/test/project")
    await commands._start(session)
    await commands._stop(session.id)

    # Clear orchestrator bridge to simulate fresh daemon state
    orchestrator.bridge = None

    # Resume session
    await commands._resume(session.id)

    # Verify bridge is set (not None)
    assert orchestrator.bridge is not None, "orchestrator.bridge should be set after _resume()"

    # Verify it's the process's bridge
    process = commands.processes[session.id]
    assert orchestrator.bridge is process.get_bridge(), "orchestrator.bridge should reference process bridge"
```

This test catches the gap if bridge is not set after resume.
  </action>
  <verify>Test passes with pytest tests/test_session_commands.py::test_resume_sets_orchestrator_bridge</verify>
  <done>Test verifies bridge is wired after resume</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] grep confirms "self.orchestrator.bridge = process.get_bridge()" exists in _start() method
- [ ] grep confirms "self.orchestrator.bridge = process.get_bridge()" exists in _resume() method
- [ ] test_start_sets_orchestrator_bridge passes
- [ ] test_resume_sets_orchestrator_bridge passes
- [ ] All existing tests still pass
</verification>

<success_criteria>

- orchestrator.bridge is set after SessionCommands._start() completes
- orchestrator.bridge is set after SessionCommands._resume() completes
- Tests verify bridge wiring in both cases
- Gap closure enables Phase 3 goal: "Commands sent from Signal execute in Claude Code CLI"
- Blocked truths (2, 6) can now be verified after this gap closes
  </success_criteria>

<output>
After completion, create `.planning/phases/03-claude-integration/03-05-SUMMARY.md`
</output>
