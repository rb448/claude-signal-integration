---
phase: 03-claude-integration
plan: 04
type: execute
wave: 3
depends_on: ["03-01", "03-02", "03-03"]
files_modified: [src/claude/orchestrator.py, tests/test_claude_orchestrator.py, src/session/commands.py]
autonomous: true

must_haves:
  truths:
    - "Signal message 'help me debug' → Claude CLI receives → response to Signal"
    - "User sends command → sees tool calls → sees result"
    - "Multiple commands in same session maintain conversation context"
  artifacts:
    - path: "src/claude/orchestrator.py"
      provides: "ClaudeOrchestrator coordinates command flow"
      min_lines: 100
      exports: ["ClaudeOrchestrator"]
    - path: "tests/test_claude_orchestrator.py"
      provides: "Integration tests for command flow"
      contains: "test_execute_command_end_to_end"
  key_links:
    - from: "ClaudeOrchestrator.execute()"
      to: "CLIBridge.send_command()"
      via: "sends command to CLI"
      pattern: "bridge\\.send_command"
    - from: "ClaudeOrchestrator.execute()"
      to: "CLIBridge.read_response()"
      via: "reads CLI output"
      pattern: "bridge\\.read_response"
    - from: "ClaudeOrchestrator"
      to: "SignalResponder"
      via: "formats for Signal"
      pattern: "responder\\.format"
---

<objective>
Wire end-to-end command flow: Signal → Claude CLI → Signal

Purpose: Complete bidirectional integration so commands execute and responses return
Output: ClaudeOrchestrator managing full command lifecycle
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Previous plans - all components ready
@.planning/phases/03-claude-integration/03-01-SUMMARY.md
@.planning/phases/03-claude-integration/03-02-SUMMARY.md
@.planning/phases/03-claude-integration/03-03-SUMMARY.md

# Existing code to wire together
@src/claude/bridge.py
@src/claude/parser.py
@src/claude/responder.py
@src/session/commands.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ClaudeOrchestrator (TDD RED-GREEN-REFACTOR)</name>
  <files>tests/test_claude_orchestrator.py, src/claude/orchestrator.py</files>
  <action>
**RED**: Write failing integration tests:
- test_execute_command(): Send "help" → verify send_command called → verify response parsed → verify formatted
- test_stream_output(): Mock streaming response → verify each line parsed → verify batched sends
- test_handle_error(): Mock error output → verify Error parsed → verify error message formatted
- test_command_with_tool_calls(): Mock response with tool calls → verify all tool calls captured

**GREEN**: Implement ClaudeOrchestrator:
- __init__(bridge: CLIBridge, parser: OutputParser, responder: SignalResponder, send_signal: Callable)
- async execute_command(command: str, session_id: str) -> None:
  1. Send command via bridge.send_command()
  2. Read response via bridge.read_response() (async generator)
  3. For each line: parser.parse() → responder.format() → batch
  4. Periodically flush batch via send_signal callback
- Store session_id for Signal routing

Use asyncio.gather for concurrent read/send when batching. Handle CLIBridge exceptions and convert to Error events.

**REFACTOR**: Extract batching interval to constant if hardcoded.

**TDD Strategy**: Write test → run (fails) → implement → run (passes) → refactor → commit each phase
  </action>
  <verify>pytest tests/test_claude_orchestrator.py -v passes</verify>
  <done>ClaudeOrchestrator coordinates command → CLI → parse → format → Signal flow</done>
</task>

<task type="auto">
  <name>Task 2: Integrate ClaudeOrchestrator into SessionCommands</name>
  <files>src/session/commands.py</files>
  <action>
Wire ClaudeOrchestrator into existing session management:

1. Add orchestrator parameter to __init__:
   - claude_orchestrator: ClaudeOrchestrator (receives instance from daemon)

2. Add handle_claude_command() method:
   - Parse non-/session messages as Claude commands
   - Get active session for thread_id
   - If no active session: return "Start a session first: /session start <path>"
   - If session exists: orchestrator.execute_command(message, session.id)
   - Return confirmation message

3. Update handle() to route:
   - If message.startswith("/session"): route to existing _start/_list/_resume/_stop
   - Else: route to handle_claude_command()

NO changes to existing session commands - only adds Claude command routing.
  </action>
  <verify>pytest tests/test_session_commands.py passes (existing tests + new orchestrator tests)</verify>
  <done>SessionCommands routes non-/session messages to ClaudeOrchestrator</done>
</task>

<task type="auto">
  <name>Task 3: Update daemon to instantiate ClaudeOrchestrator</name>
  <files>src/daemon/service.py</files>
  <action>
In SignalDaemon.__init__():
- Create OutputParser instance
- Create SignalResponder instance
- Create ClaudeOrchestrator(None, parser, responder, self.signal_client.send_message)
  - bridge=None initially, set when session starts
- Pass orchestrator to SessionCommands constructor

In _handle_message():
- SessionCommands.handle() now routes both /session and Claude commands
- No other changes needed - orchestrator wired through SessionCommands

Simple integration - all components already exist, just wire dependencies.
  </action>
  <verify>python -m pytest tests/test_daemon.py passes</verify>
  <done>Daemon instantiates and wires ClaudeOrchestrator through SessionCommands</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] pytest tests/test_claude_orchestrator.py -v passes
- [ ] pytest tests/test_session_commands.py -v passes
- [ ] pytest tests/test_daemon.py passes
- [ ] git log shows TDD commits for orchestrator
- [ ] End-to-end flow: Signal → Claude CLI → Signal works
</verification>

<success_criteria>

- All tests pass
- TDD commits for ClaudeOrchestrator
- Commands from Signal execute in Claude CLI
- Responses stream back to Signal
- Tool calls, progress, errors all display correctly
- Integration complete - Phase 3 goal achieved
</success_criteria>

<output>
After completion, create `.planning/phases/03-claude-integration/03-04-SUMMARY.md`
</output>
