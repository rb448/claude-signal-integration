---
phase: 06-code-display
plan: 06
type: execute
wave: 4
depends_on: ["06-01", "06-02", "06-03", "06-04", "06-05"]
files_modified: [src/claude/responder.py, src/session/commands.py, tests/test_claude_responder.py, tests/test_session_commands.py]
autonomous: true

must_haves:
  truths:
    - "Code automatically displays with formatting and highlighting when Claude outputs code"
    - "User can request full code view with `/code full` command"
    - "Diffs automatically render with mobile-friendly layout"
    - "Long code sends as attachments automatically"
  artifacts:
    - path: "src/claude/responder.py"
      provides: "Integration of code display components"
      contains: "CodeFormatter|SyntaxHighlighter|DiffRenderer"
    - path: "src/session/commands.py"
      provides: "/code command implementation"
      contains: "/code.*full"
  key_links:
    - from: "SignalResponder.format()"
      to: "CodeFormatter/SyntaxHighlighter"
      via: "code detection and formatting"
      pattern: "format_code|highlight"
    - from: "SignalResponder.format()"
      to: "DiffRenderer"
      via: "diff detection and rendering"
      pattern: "diff|render.*changes"
    - from: "SignalResponder.format()"
      to: "AttachmentHandler"
      via: "length detection and upload"
      pattern: "should_attach|send_code_file"
---

<objective>
Wire code display components into SignalResponder and add `/code` command for user control.

Purpose: Make code formatting, highlighting, diff rendering, and attachments work automatically for all Claude output.

Output: Fully integrated code display system with automatic detection and manual `/code full` command.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md

# All prior plans in this phase:
@.planning/phases/06-code-display/06-01-PLAN.md
@.planning/phases/06-code-display/06-02-PLAN.md
@.planning/phases/06-code-display/06-03-PLAN.md
@.planning/phases/06-code-display/06-04-PLAN.md
@.planning/phases/06-code-display/06-05-PLAN.md

# Source files to modify:
@src/claude/responder.py
@src/session/commands.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate code display into SignalResponder</name>
  <files>src/claude/responder.py, tests/test_claude_responder.py</files>
  <action>
Enhance SignalResponder.format() to automatically detect and format code:

**RED - Write failing tests first:**
1. Test: Detects code blocks (```language...```) in Response output
2. Test: Formats detected code with CodeFormatter
3. Test: Highlights detected code with SyntaxHighlighter
4. Test: Detects git diff output (starts with "diff --git")
5. Test: Renders diffs with DiffRenderer
6. Test: Generates plain-English summary with SummaryGenerator before diff
7. Test: Detects long code (>100 lines) and triggers attachment mode
8. Test: Preserves non-code text formatting (existing behavior)
9. Test: Handles mixed content (text + code + diff in single response)

**GREEN - Implement integration:**
```python
from src.claude.code_formatter import CodeFormatter, LengthDetector
from src.claude.syntax_highlighter import SyntaxHighlighter
from src.claude.diff_processor import DiffParser, SummaryGenerator
from src.claude.diff_renderer import DiffRenderer
from src.signal.attachment_handler import AttachmentHandler

class SignalResponder:
    def __init__(self, signal_api_url: str = "http://localhost:8080"):
        # Existing emoji constants...

        # Code display components
        self.code_formatter = CodeFormatter()
        self.syntax_highlighter = SyntaxHighlighter()
        self.length_detector = LengthDetector()
        self.diff_parser = DiffParser()
        self.diff_renderer = DiffRenderer()
        self.summary_generator = SummaryGenerator()
        self.attachment_handler = AttachmentHandler(signal_api_url)

    def format(self, output: ParsedOutput) -> str:
        """Format Claude output with code display enhancements."""
        # Existing ToolCall, Progress, Error handling...

        if isinstance(output, Response):
            return self._format_response_with_code(output.content)

        # ...existing code...

    def _format_response_with_code(self, content: str) -> str:
        """Format response with code/diff detection and formatting."""

        # Detect git diff output (highest priority - most structured)
        if self._is_diff(content):
            return self._format_diff(content)

        # Detect code blocks ```language...```
        if "```" in content:
            return self._format_code_blocks(content)

        # Plain text - existing formatting
        return content

    def _is_diff(self, content: str) -> bool:
        """Check if content is git diff output."""
        return content.strip().startswith("diff --git")

    def _format_diff(self, content: str) -> str:
        """Format git diff with summary and rendering."""
        # Parse diff
        file_diffs = self.diff_parser.parse(content)

        # Generate plain-English summary
        summary = self.summary_generator.generate(file_diffs)

        # Render diff
        rendered = self.diff_renderer.render(file_diffs)

        return f"**Changes:**\n{summary}\n\n{rendered}"

    def _format_code_blocks(self, content: str) -> str:
        """Format embedded code blocks."""
        import re

        # Find all code blocks: ```language\ncode\n```
        pattern = r'```(\w+)?\n(.*?)\n```'

        def replace_code(match):
            language = match.group(1)
            code = match.group(2)

            # Check length - attachment vs inline
            if self.length_detector.should_attach(code):
                # TODO: Trigger attachment (needs recipient context)
                return f"[Code too long ({code.count(chr(10))} lines) - attachment coming...]"

            # Format and highlight for inline display
            formatted = self.code_formatter.format_code(code, language)
            highlighted = self.syntax_highlighter.highlight(formatted, language)
            return f"```\n{highlighted}\n```"

        return re.sub(pattern, replace_code, content, flags=re.DOTALL)
```

**Implementation notes:**
- Detection order: diff â†’ code blocks â†’ plain text
- Diff: Always summarize before showing details (mobile UX)
- Code blocks: Format + highlight automatically
- Attachment mode: Requires recipient context (deferred to Task 2)

Commit pattern:
1. `test(06-06): add tests for code display integration`
2. `feat(06-06): integrate code display into SignalResponder`
  </action>
  <verify>pytest tests/test_claude_responder.py::test_format_with_code -v passes</verify>
  <done>SignalResponder automatically detects and formats code, diffs, and triggers attachments</done>
</task>

<task type="auto">
  <name>Task 2: Add /code command for user control</name>
  <files>src/session/commands.py, tests/test_session_commands.py</files>
  <action>
Add `/code` command to SessionCommands for user-controlled display:

**RED - Write failing tests first:**
1. Test: `/code full` returns last code output without truncation
2. Test: `/code full` works for diffs (shows all context, no collapse)
3. Test: `/code full` works for long files (sends as attachment)
4. Test: `/code` with no args shows help text
5. Test: `/code` when no recent code returns "No code in recent messages"
6. Test: `/code help` shows command usage

**GREEN - Implement command:**
```python
class SessionCommands:
    # ... existing commands ...

    async def handle(self, message: str, recipient: str) -> str:
        """Route commands to handlers."""
        # Existing routing...

        if message.startswith("/code"):
            return await self._handle_code_command(message, recipient)

        # ... existing code ...

    async def _handle_code_command(self, message: str, recipient: str) -> str:
        """
        Handle /code command for code display control.

        Commands:
        - /code full: Show full code view (no truncation, all context)
        - /code help: Show command help
        """
        parts = message.split(maxsplit=1)
        subcommand = parts[1] if len(parts) > 1 else ""

        if subcommand == "full":
            return await self._code_full(recipient)
        elif subcommand == "help" or subcommand == "":
            return self._code_help()
        else:
            return f"Unknown subcommand: /code {subcommand}\n\nUse /code help for usage."

    async def _code_full(self, recipient: str) -> str:
        """Display last code output without truncation."""
        # Get last code/diff from session history
        # (Requires session context - simplified for now)

        # TODO: Store last code output in session context
        # For now, return placeholder
        return "Full code view not yet implemented - coming in next iteration"

    def _code_help(self) -> str:
        """Show /code command help."""
        return """**Code Display Commands**

/code full - Show full code view (no truncation)
  â€¢ Diffs: All context shown (no collapse)
  â€¢ Long files: Sent as attachment
  â€¢ Recent: Last code from Claude

/code help - Show this help

**Automatic Display:**
â€¢ Code <20 lines: Inline with formatting
â€¢ Code 20-100 lines: Inline (use /code full for details)
â€¢ Code >100 lines: Attachment
â€¢ Diffs: Summary + rendered changes
"""
```

**Implementation notes:**
- `/code full` requires session history tracking (session.context)
- Placeholder response for now (full implementation needs ClaudeOrchestrator changes)
- Help text documents automatic behavior + manual control

**Phase scope decision:**
- Full `/code full` implementation requires storing last code in session context
- That's a ClaudeOrchestrator change (not just SignalResponder)
- For Phase 6: Wire command routing, provide help, return placeholder for `/code full`
- Phase 7 (Connection Resilience) includes session state sync - natural place for `/code full` completion

Commit pattern:
1. `test(06-06): add tests for /code command`
2. `feat(06-06): add /code command routing with help text`
  </action>
  <verify>pytest tests/test_session_commands.py::test_code_command -v passes</verify>
  <done>/code command routed with help text, placeholder for /code full (completion deferred to Phase 7)</done>
</task>

<task type="auto">
  <name>Task 3: Wire attachment context for long code</name>
  <files>src/claude/responder.py, tests/test_claude_responder.py</files>
  <action>
Enable attachment uploads for long code in SignalResponder:

**Implementation approach:**
SignalResponder currently doesn't have recipient context. Two options:

**Option A: Pass recipient to format()**
```python
def format(self, output: ParsedOutput, recipient: str = None) -> str:
    # ... now has recipient for attachments ...
```

**Option B: Add send_with_attachments() method**
```python
async def send_with_attachments(
    self,
    formatted_message: str,
    recipient: str
) -> str:
    """
    Post-process formatted message to handle attachment uploads.

    Detects [Code too long...] markers and replaces with actual attachment upload.
    """
    # Scan for attachment markers
    # Upload via AttachmentHandler
    # Replace markers with "ðŸ“Ž Sent {filename}"
```

**Decision: Option B (cleaner separation)**
- format() stays pure (output â†’ string)
- send_with_attachments() handles I/O (upload)
- Caller (ClaudeOrchestrator) chains: format() â†’ send_with_attachments() â†’ send to Signal

**GREEN - Implement:**
```python
class SignalResponder:
    async def send_with_attachments(
        self,
        formatted_message: str,
        code_blocks: List[tuple[str, str]],  # [(code, filename), ...]
        recipient: str
    ) -> str:
        """
        Upload code attachments and update message with attachment confirmations.

        Args:
            formatted_message: Message with [attachment needed] markers
            code_blocks: Code content and filenames for attachments
            recipient: Phone number to send attachments to

        Returns:
            Updated message with attachment confirmations
        """
        for code, filename in code_blocks:
            attachment_id = await self.attachment_handler.send_code_file(
                recipient, code, filename
            )

            if attachment_id:
                # Replace marker with confirmation
                formatted_message = formatted_message.replace(
                    f"[Code too long ({code.count(chr(10))} lines) - attachment coming...]",
                    f"ðŸ“Ž Sent {filename} ({code.count(chr(10))} lines)"
                )

        return formatted_message
```

**Integration in ClaudeOrchestrator:**
```python
# In ClaudeOrchestrator (pseudocode for context):
formatted = self.responder.format(output)
if needs_attachments:
    formatted = await self.responder.send_with_attachments(
        formatted, code_blocks, recipient
    )
await signal_client.send(recipient, formatted)
```

**Commit pattern:**
1. `test(06-06): add tests for attachment context wiring`
2. `feat(06-06): add send_with_attachments for long code uploads`
  </action>
  <verify>pytest tests/test_claude_responder.py::test_send_with_attachments -v passes</verify>
  <done>SignalResponder.send_with_attachments() uploads long code files and updates messages</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] pytest tests/test_claude_responder.py -v passes
- [ ] pytest tests/test_session_commands.py -v passes
- [ ] Code blocks automatically formatted and highlighted
- [ ] Diffs automatically rendered with summaries
- [ ] Long code triggers attachment mode (tested with mocks)
- [ ] /code command routes correctly with help text
</verification>

<success_criteria>
- All tasks completed
- TDD RED-GREEN-REFACTOR cycle followed
- SignalResponder detects code blocks and diffs automatically
- Code formatting, highlighting, diff rendering integrated
- Attachment handler wired for long code
- /code command added with help text (/code full placeholder for Phase 7)
- All tests passing (minimum 15 tests across responder and commands)
</success_criteria>

<output>
After completion, create `.planning/phases/06-code-display/06-06-SUMMARY.md`
</output>
