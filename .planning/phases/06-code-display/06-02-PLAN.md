---
phase: 06-code-display
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [src/claude/syntax_highlighter.py, tests/test_syntax_highlighter.py, requirements.txt]
autonomous: true

must_haves:
  truths:
    - "Code displays with syntax highlighting on mobile screens"
    - "Highlighting theme optimized for small screens (readable contrast)"
  artifacts:
    - path: "src/claude/syntax_highlighter.py"
      provides: "Pygments-based syntax highlighting with mobile theme"
      exports: ["SyntaxHighlighter"]
      min_lines: 40
    - path: "tests/test_syntax_highlighter.py"
      provides: "Test coverage for syntax highlighting"
      min_lines: 30
  key_links:
    - from: "SyntaxHighlighter.highlight()"
      to: "Pygments"
      via: "lexer selection and formatting"
      pattern: "pygments.*lexer|get_lexer"
    - from: "Highlighted output"
      to: "Terminal256Formatter"
      via: "ANSI color codes for Signal"
      pattern: "Terminal256|ansi|color"
---

<objective>
Implement syntax highlighting optimized for mobile display with high-contrast themes.

Purpose: Make code more readable on small screens by adding color-coded syntax elements.

Output: SyntaxHighlighter class using Pygments with mobile-optimized ANSI themes ready for Signal display.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md

# Current Python environment and dependencies:
@requirements.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Pygments and create SyntaxHighlighter</name>
  <files>requirements.txt, src/claude/syntax_highlighter.py, tests/test_syntax_highlighter.py</files>
  <action>
**Step 1: Add Pygments dependency**

Add to requirements.txt:
```
pygments>=2.17.0  # Syntax highlighting with ANSI terminal support
```

**Step 2: RED - Write failing tests:**
1. Test: highlight() with Python code returns ANSI-colored output (contains escape codes)
2. Test: highlight() with JavaScript code returns ANSI-colored output
3. Test: highlight() auto-detects language from code content (Python, JS, Rust, Go)
4. Test: highlight() with unknown language falls back to plain text (no errors)
5. Test: highlight() with empty code returns empty string (doesn't crash)
6. Test: Strip ANSI codes helper works (for testing output without color codes)

**Step 3: GREEN - Implement to pass:**
```python
from pygments import highlight as pygments_highlight
from pygments.lexers import get_lexer_by_name, guess_lexer
from pygments.formatters import Terminal256Formatter
from pygments.util import ClassNotFound

class SyntaxHighlighter:
    """Syntax highlighting for mobile display using ANSI terminal colors."""

    def __init__(self):
        # Use Terminal256Formatter with monokai style (high contrast, mobile-friendly)
        self.formatter = Terminal256Formatter(style='monokai')

    def highlight(self, code: str, language: str | None = None) -> str:
        """Apply syntax highlighting with ANSI color codes."""
        if not code:
            return ""

        try:
            if language:
                lexer = get_lexer_by_name(language)
            else:
                lexer = guess_lexer(code)  # Auto-detect

            return pygments_highlight(code, lexer, self.formatter)
        except ClassNotFound:
            # Unknown language - return plain text
            return code
```

**Why Terminal256Formatter:**
- Signal mobile app supports ANSI color codes in monospace text
- 256-color palette provides good syntax distinction
- Monokai style has high contrast (readable on mobile screens)

**Why auto-detection:**
- User doesn't need to specify language
- Pygments guess_lexer works well for common languages
- Graceful fallback to plain text for unknown formats

**REFACTOR (if needed):**
- Extract formatter setup to _create_formatter() if we add theme selection
- Add style parameter if user wants light vs dark theme options

Commit pattern:
1. `chore(06-02): add Pygments dependency for syntax highlighting`
2. `test(06-02): add failing tests for syntax highlighting`
3. `feat(06-02): implement SyntaxHighlighter with Pygments`
  </action>
  <verify>pytest tests/test_syntax_highlighter.py -v passes, pip install -r requirements.txt succeeds</verify>
  <done>SyntaxHighlighter highlights code with ANSI colors optimized for mobile display</done>
</task>

<task type="auto">
  <name>Task 2: Add language detection improvements</name>
  <files>src/claude/syntax_highlighter.py, tests/test_syntax_highlighter.py</files>
  <action>
Enhance SyntaxHighlighter with better language detection:

**RED - Write failing tests:**
1. Test: Detects Python from `def` and `import` keywords
2. Test: Detects JavaScript from `const` and `function` keywords
3. Test: Detects TypeScript from type annotations
4. Test: Detects Rust from `fn` and ownership syntax
5. Test: Detects Go from `package` and `func` keywords
6. Test: Falls back to plain text for prose/documentation

**GREEN - Improve detection:**
```python
def _get_lexer(self, code: str, language: str | None) -> Lexer:
    """Get lexer with improved detection for common languages."""
    if language:
        try:
            return get_lexer_by_name(language)
        except ClassNotFound:
            pass  # Fall through to guess

    # Try Pygments auto-detection
    try:
        lexer = guess_lexer(code)
        # If confidence is low (generic "Text" lexer), try pattern matching
        if lexer.name == "Text":
            return self._detect_by_patterns(code)
        return lexer
    except ClassNotFound:
        return get_lexer_by_name('text')

def _detect_by_patterns(self, code: str) -> Lexer:
    """Fallback detection using keyword patterns."""
    patterns = {
        'python': r'\b(def|import|class|from)\b',
        'javascript': r'\b(const|let|var|function)\b',
        'typescript': r':\s*(string|number|boolean|any)\b',
        'rust': r'\b(fn|impl|struct|enum)\b',
        'go': r'\b(package|func|import)\b',
    }

    import re
    for lang, pattern in patterns.items():
        if re.search(pattern, code):
            try:
                return get_lexer_by_name(lang)
            except ClassNotFound:
                continue

    return get_lexer_by_name('text')
```

**Rationale:**
- Pygments guess_lexer is good but conservative (often returns "Text" for short snippets)
- Pattern matching catches common languages from keywords
- Still graceful fallback to plain text if nothing matches

Commit pattern:
1. `test(06-02): add tests for improved language detection`
2. `feat(06-02): enhance language detection with keyword patterns`
  </action>
  <verify>pytest tests/test_syntax_highlighter.py -v passes with improved detection tests</verify>
  <done>Language detection works reliably for Python, JS, TS, Rust, Go with graceful fallbacks</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] pytest tests/test_syntax_highlighter.py -v passes
- [ ] Pygments installed: `python -c "import pygments; print(pygments.__version__)"`
- [ ] ANSI codes present in output: colored output visible when printed to terminal
- [ ] Unknown languages don't crash (return plain text)
</verification>

<success_criteria>
- All tasks completed
- TDD RED-GREEN-REFACTOR cycle followed
- Pygments dependency added and installed
- SyntaxHighlighter highlights Python, JS, TS, Rust, Go
- ANSI color output optimized for mobile (Terminal256Formatter + monokai)
- Auto-detection works for common languages with fallback to plain text
- All tests passing (minimum 12 tests)
</success_criteria>

<output>
After completion, create `.planning/phases/06-code-display/06-02-SUMMARY.md`
</output>
