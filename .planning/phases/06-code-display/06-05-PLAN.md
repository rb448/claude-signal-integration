---
phase: 06-code-display
plan: 05
type: execute
wave: 3
depends_on: ["06-01"]
files_modified: [src/signal/attachment_handler.py, tests/test_attachment_handler.py]
autonomous: true

must_haves:
  truths:
    - "Long code files (>100 lines) send as Signal attachments"
    - "Attachments upload successfully via Signal API"
  artifacts:
    - path: "src/signal/attachment_handler.py"
      provides: "Signal attachment upload with temp file management"
      exports: ["AttachmentHandler"]
      min_lines: 40
    - path: "tests/test_attachment_handler.py"
      provides: "Test coverage for attachment handling"
      min_lines: 30
  key_links:
    - from: "AttachmentHandler.send_code_file()"
      to: "Signal API"
      via: "attachment upload endpoint"
      pattern: "attachment|upload|send.*file"
    - from: "Code content"
      to: "Temp file"
      via: "write to disk for upload"
      pattern: "tempfile|NamedTemporaryFile"
---

<objective>
Implement Signal attachment handling for sending long code files.

Purpose: Enable code files >100 lines to be sent as downloadable attachments instead of massive inline messages.

Output: AttachmentHandler that creates temp files and uploads via Signal API.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md

# Signal client from Phase 1:
@src/signal/client.py

# Code formatter from Plan 01:
@.planning/phases/06-code-display/06-01-PLAN.md
@src/claude/code_formatter.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AttachmentHandler for Signal file uploads</name>
  <files>src/signal/attachment_handler.py, tests/test_attachment_handler.py</files>
  <action>
Create AttachmentHandler class following TDD:

**RED - Write failing tests first:**
1. Test: send_code_file() creates temp file with code content
2. Test: send_code_file() uploads to Signal via REST API POST /v2/send endpoint
3. Test: send_code_file() includes filename in upload (e.g., "user.py", "config.json")
4. Test: send_code_file() cleans up temp file after upload (even on error)
5. Test: send_code_file() handles upload failures (network error, API error)
6. Test: send_code_file() returns attachment ID from Signal API
7. Test: Edge cases (empty code, very large files, special chars in filename)

**GREEN - Implement to pass:**
```python
import tempfile
import os
from pathlib import Path
from typing import Optional

class AttachmentHandler:
    """Handle Signal file attachments for code display."""

    def __init__(self, signal_api_url: str):
        self.signal_api_url = signal_api_url

    async def send_code_file(
        self,
        recipient: str,
        code: str,
        filename: str,
        language: str = None
    ) -> Optional[str]:
        """
        Send code as Signal attachment.

        Args:
            recipient: Phone number to send to
            code: Code content
            filename: Display filename (e.g., "user.py")
            language: Optional language for syntax detection

        Returns:
            Attachment ID from Signal API, or None if upload failed
        """
        temp_path = None
        try:
            # Create temp file with code content
            suffix = Path(filename).suffix or ".txt"
            temp_path = self._create_temp_file(code, suffix)

            # Upload to Signal via REST API
            attachment_id = await self._upload_attachment(
                temp_path, recipient, filename
            )

            return attachment_id

        finally:
            # Cleanup temp file (even if upload failed)
            if temp_path and os.path.exists(temp_path):
                os.unlink(temp_path)

    def _create_temp_file(self, content: str, suffix: str) -> str:
        """Write content to temp file and return path."""
        with tempfile.NamedTemporaryFile(
            mode='w',
            suffix=suffix,
            delete=False,
            encoding='utf-8'
        ) as f:
            f.write(content)
            return f.name

    async def _upload_attachment(
        self,
        file_path: str,
        recipient: str,
        display_name: str
    ) -> Optional[str]:
        """
        Upload file to Signal via REST API.

        Signal API expects POST to /v2/send with:
        - number: sender (from daemon config)
        - recipients: [recipient]
        - message: optional caption
        - attachments: [file_path]
        """
        import aiohttp

        url = f"{self.signal_api_url}/v2/send"
        data = {
            "recipients": [recipient],
            "message": f"ðŸ“Ž {display_name}",  # Caption with filename
            "attachments": [file_path]
        }

        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(url, json=data) as response:
                    if response.status == 200:
                        result = await response.json()
                        # Signal returns response with timestamp
                        return result.get("timestamp")
                    else:
                        # Log error but don't crash
                        error_text = await response.text()
                        print(f"Signal attachment upload failed: {response.status} {error_text}")
                        return None

        except Exception as e:
            print(f"Exception uploading attachment: {e}")
            return None
```

**Why temp files:**
- Signal API expects file path (not in-memory bytes)
- Temp file with delete=False gives us control over cleanup timing
- Cleanup in finally block ensures no leaked files even on error

**Why aiohttp:**
- Already using asyncio throughout daemon
- Project likely already has aiohttp dependency for signal-cli-rest-api
- If not present, will be added to requirements.txt

**Error handling:**
- Non-blocking: attachment failure doesn't crash daemon
- Logged: failures visible in daemon logs for debugging
- Graceful: returns None on failure, caller can retry or fall back to inline

Commit pattern:
1. `test(06-05): add failing tests for Signal attachment handling`
2. `feat(06-05): implement AttachmentHandler for code file uploads`
  </action>
  <verify>pytest tests/test_attachment_handler.py -v passes</verify>
  <done>AttachmentHandler uploads code files as Signal attachments with temp file cleanup</done>
</task>

<task type="auto">
  <name>Task 2: Add attachment size limits and validation</name>
  <files>src/signal/attachment_handler.py, tests/test_attachment_handler.py</files>
  <action>
Add size limits and validation to AttachmentHandler:

**RED - Write failing tests first:**
1. Test: Rejects files over 100MB (Signal API limit)
2. Test: Warns for files over 10MB (large for mobile download)
3. Test: Handles filenames with special characters (sanitizes if needed)
4. Test: Validates recipient phone number format
5. Test: Handles concurrent uploads (multiple attachments in flight)

**GREEN - Implement validation:**
```python
import re

class AttachmentHandler:
    MAX_SIZE_BYTES = 100 * 1024 * 1024  # 100MB Signal limit
    LARGE_FILE_THRESHOLD = 10 * 1024 * 1024  # 10MB warning threshold

    # ... existing __init__ ...

    async def send_code_file(
        self,
        recipient: str,
        code: str,
        filename: str,
        language: str = None
    ) -> Optional[str]:
        """Send code as Signal attachment with validation."""

        # Validate size
        size_bytes = len(code.encode('utf-8'))
        if size_bytes > self.MAX_SIZE_BYTES:
            print(f"Code file too large ({size_bytes} bytes > {self.MAX_SIZE_BYTES})")
            return None

        if size_bytes > self.LARGE_FILE_THRESHOLD:
            print(f"Warning: Large code file ({size_bytes / 1024 / 1024:.1f}MB)")

        # Sanitize filename (remove path traversal, invalid chars)
        safe_filename = self._sanitize_filename(filename)

        # Validate recipient (E.164 format)
        if not self._is_valid_phone(recipient):
            print(f"Invalid recipient phone number: {recipient}")
            return None

        # Continue with upload...
        temp_path = None
        try:
            suffix = Path(safe_filename).suffix or ".txt"
            temp_path = self._create_temp_file(code, suffix)
            attachment_id = await self._upload_attachment(
                temp_path, recipient, safe_filename
            )
            return attachment_id
        finally:
            if temp_path and os.path.exists(temp_path):
                os.unlink(temp_path)

    def _sanitize_filename(self, filename: str) -> str:
        """Remove path traversal and invalid characters."""
        # Get basename (removes any directory path)
        safe = os.path.basename(filename)
        # Remove/replace invalid chars for cross-platform safety
        safe = re.sub(r'[<>:"/\\|?*]', '_', safe)
        # Ensure not empty
        return safe if safe else "code.txt"

    def _is_valid_phone(self, phone: str) -> bool:
        """Validate E.164 phone number format."""
        # E.164: +[country][number], 1-15 digits total
        pattern = r'^\+[1-9]\d{1,14}$'
        return bool(re.match(pattern, phone))
```

**Why these limits:**
- 100MB: Signal API hard limit (requests fail above this)
- 10MB warning: Mobile data consideration (user should know before download)
- Filename sanitization: Security (prevent path traversal) + compatibility (cross-platform)
- Phone validation: Fail fast on invalid recipient (better than silent Signal API error)

Commit pattern:
1. `test(06-05): add tests for attachment size limits and validation`
2. `feat(06-05): add size limits and filename sanitization`
  </action>
  <verify>pytest tests/test_attachment_handler.py -v passes (including validation tests)</verify>
  <done>AttachmentHandler validates size limits, sanitizes filenames, and validates phone numbers</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] pytest tests/test_attachment_handler.py -v passes
- [ ] Temp files cleaned up after upload (no leaked files in /tmp)
- [ ] Size validation prevents oversized uploads
- [ ] Filename sanitization removes path traversal attempts
- [ ] Error handling prevents daemon crashes on upload failure
</verification>

<success_criteria>
- All tasks completed
- TDD RED-GREEN-REFACTOR cycle followed
- AttachmentHandler creates temp files with code content
- Uploads via Signal REST API POST /v2/send
- Cleanup ensures no temp file leaks (even on error)
- Size validation enforces 100MB limit, warns at 10MB
- Filename sanitization prevents security issues
- Phone number validation catches invalid recipients
- All tests passing (minimum 12 tests)
</success_criteria>

<output>
After completion, create `.planning/phases/06-code-display/06-05-SUMMARY.md`
</output>
