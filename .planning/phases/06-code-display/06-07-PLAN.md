---
phase: 06-code-display
plan: 07
type: execute
wave: 1
depends_on: []
files_modified:
  - src/claude/orchestrator.py
  - tests/test_claude_orchestrator.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Long code (>100 lines) sends as file attachments"
  artifacts:
    - path: "src/claude/orchestrator.py"
      provides: "Attachment upload integration in execute_command()"
      min_lines: 180
      exports: ["ClaudeOrchestrator"]
  key_links:
    - from: "orchestrator.execute_command()"
      to: "responder.send_with_attachments()"
      via: "post-processing after format()"
      pattern: "send_with_attachments"
---

<objective>
Wire attachment upload into orchestrator to close gap: long code (>100 lines) must send as Signal attachments.

Purpose: Complete the attachment upload flow by connecting existing attachment infrastructure to the orchestrator's message processing pipeline.

Output: Orchestrator detects attachment markers in formatted messages, extracts code blocks from parsed output, and calls send_with_attachments() to upload files before sending messages to Signal.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Verification gap context
@.planning/phases/06-code-display/06-VERIFICATION.md

# Prior phase context - attachment infrastructure
@.planning/phases/06-code-display/06-05-SUMMARY.md
@.planning/phases/06-code-display/06-06-SUMMARY.md

# Source files with context
@src/claude/orchestrator.py
@src/claude/responder.py
@src/signal/attachment_handler.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add attachment detection and upload to orchestrator</name>
  <files>src/claude/orchestrator.py</files>
  <action>
    In execute_command() method, after line 117 `formatted = self.responder.format(parsed)`:

    1. Detect attachment markers in formatted message
       - Pattern: `[Code too long (\d+) lines) - attachment coming...]`
       - If marker found, extract code blocks from parsed output

    2. Extract code blocks from parsed output
       - If parsed.type == OutputType.CODE_OUTPUT or OutputType.BASH_OUTPUT:
         - code_content = parsed.content (the raw code before formatting)
         - Generate filename: "code_output_<timestamp>.txt" for CODE_OUTPUT
         - Generate filename: "bash_output_<timestamp>.txt" for BASH_OUTPUT
       - Store as list of (code_content, filename) tuples

    3. Call send_with_attachments if markers detected
       - Get recipient from self.session_id (need to pass through from daemon)
       - For now, use temporary recipient parameter added to execute_command
       - formatted = await self.responder.send_with_attachments(formatted, code_blocks, recipient)

    4. Continue with existing batching flow
       - Updated formatted message (with markers replaced) goes to batcher.add()

    Implementation notes:
    - Add recipient: str parameter to execute_command() signature
    - Import re for pattern matching
    - Keep change minimal - only add detection + upload between format() and batcher.add()
    - Do NOT modify approval workflow or other orchestrator logic
  </action>
  <verify>
    - TypeScript type checks pass: mypy src/claude/orchestrator.py (or equivalent)
    - Pattern matches marker format from responder.py line 143
    - Code blocks extracted only when markers present (no-op if no attachments)
  </verify>
  <done>
    - execute_command() has recipient parameter
    - Marker detection regex matches responder format
    - send_with_attachments() called when markers detected
    - Updated message sent to batcher (attachment confirmations replace markers)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for attachment upload integration</name>
  <files>tests/test_claude_orchestrator.py</files>
  <action>
    Add test case: test_execute_command_with_long_code_attachment

    Setup:
    - Mock responder.format() to return message with marker:
      "Here's the output:\n[Code too long (150 lines) - attachment coming...]"
    - Mock parsed output with OutputType.CODE_OUTPUT and long code content (150 lines)
    - Mock responder.send_with_attachments() to return updated message with confirmation

    Execute:
    - await orchestrator.execute_command("some command", "session123", "+1234567890")

    Assert:
    - responder.send_with_attachments called once
    - Arguments: (formatted_message, [(code_content, filename)], recipient)
    - filename pattern matches "code_output_*.txt"
    - send_signal called with updated message (marker replaced)

    Edge case test: test_execute_command_without_attachment_markers
    - Message without markers should NOT call send_with_attachments
    - Verify send_with_attachments not called when no markers present
  </action>
  <verify>pytest tests/test_claude_orchestrator.py::test_execute_command_with_long_code_attachment -v</verify>
  <done>
    - Test passes for attachment upload integration
    - Test passes for no-op when no markers
    - Mock assertions verify correct method calls and arguments
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] pytest tests/test_claude_orchestrator.py passes
- [ ] mypy src/claude/orchestrator.py passes (type safety)
- [ ] Marker detection regex matches responder format exactly
- [ ] No new test skips introduced
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Gap closed: orchestrator now calls send_with_attachments() when markers detected
- Attachment upload flow complete: format() → detect markers → upload → replace markers → send
</success_criteria>

<output>
After completion, create `.planning/phases/06-code-display/06-07-SUMMARY.md`
</output>
