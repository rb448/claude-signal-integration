---
phase: 05-permissions
plan: 05
type: execute
wave: 3
depends_on: ["05-03", "05-04"]
files_modified:
  - src/daemon/service.py
  - tests/test_daemon.py
autonomous: true

must_haves:
  truths:
    - "Daemon initializes approval system on startup"
    - "Approval workflow available to all Claude sessions"
    - "Approval commands route through SessionCommands"
  artifacts:
    - path: "src/daemon/service.py"
      provides: "Daemon with approval system integration"
      contains: "approval_manager\\s*=\\s*ApprovalManager"
  key_links:
    - from: "SignalDaemon.__init__"
      to: "ApprovalManager()"
      via: "Creates approval manager instance"
      pattern: "ApprovalManager\\("
    - from: "SignalDaemon.start()"
      to: "ApprovalCommands"
      via: "Wires approval commands into session commands"
      pattern: "ApprovalCommands\\(.*manager"
    - from: "ClaudeOrchestrator"
      to: "ApprovalWorkflow"
      via: "Receives approval workflow for interception"
      pattern: "approval_workflow\\s*="
---

<objective>
Wire approval system into daemon startup for production deployment.

Purpose: Complete end-to-end integration - approval system available to all users
Output: Daemon with fully integrated approval workflow
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 5 plans
@.planning/phases/05-permissions/05-03-SUMMARY.md
@.planning/phases/05-permissions/05-04-SUMMARY.md

# Phase 4 daemon integration pattern
@.planning/phases/04-multi-project/04-03-SUMMARY.md
@.planning/phases/04-multi-project/04-05-SUMMARY.md
@src/daemon/service.py

# Approval components to wire
@src/approval/detector.py
@src/approval/manager.py
@src/approval/workflow.py
@src/approval/commands.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize approval system in daemon __init__</name>
  <files>src/daemon/service.py</files>
  <action>
Add approval system to SignalDaemon.__init__ (follow Phase 4-3 ThreadMapper pattern):

1. After session_manager initialization:
   ```python
   # Approval system
   self.approval_detector = OperationDetector()
   self.approval_manager = ApprovalManager()
   self.approval_workflow = ApprovalWorkflow(
       detector=self.approval_detector,
       manager=self.approval_manager
   )
   ```

2. Import required classes:
   ```python
   from src.approval.detector import OperationDetector
   from src.approval.manager import ApprovalManager
   from src.approval.workflow import ApprovalWorkflow
   from src.approval.commands import ApprovalCommands
   ```

Approval components stateless (no async initialize needed unlike SessionManager).
  </action>
  <verify>Daemon initializes without errors, approval attributes present</verify>
  <done>Approval system components created in daemon __init__</done>
</task>

<task type="auto">
  <name>Task 2: Wire ApprovalCommands into command routing</name>
  <files>src/daemon/service.py</files>
  <action>
Wire ApprovalCommands into SessionCommands in start() method (follow Phase 4-3 pattern):

1. After thread_commands creation, create approval_commands:
   ```python
   # Approval commands (no async init needed)
   approval_commands = ApprovalCommands(manager=self.approval_manager)
   ```

2. Wire into session_commands (after thread_commands wiring):
   ```python
   session_commands.approval_commands = approval_commands
   ```

3. Update help command routing priority (in SessionCommands.handle):
   - approval_commands (most urgent)
   - thread_commands
   - session_commands (fallback)

Follow Phase 4-3 pattern: create after SessionCommands, wire via property assignment.
  </action>
  <verify>Approval commands route correctly through session_commands hierarchy</verify>
  <done>ApprovalCommands wired into daemon command routing</done>
</task>

<task type="auto">
  <name>Task 3: Pass ApprovalWorkflow to ClaudeOrchestrator</name>
  <files>src/daemon/service.py</files>
  <action>
Wire approval workflow into orchestrator creation (in SessionCommands methods):

1. In SessionCommands._start() method, when creating ClaudeOrchestrator:
   ```python
   orchestrator = ClaudeOrchestrator(
       callback=self._send_message,
       bridge=None,  # Set after process starts
       approval_workflow=self.daemon.approval_workflow  # NEW
   )
   ```

2. In SessionCommands._resume() method, same pattern for orchestrator creation

3. Add daemon reference to SessionCommands.__init__:
   ```python
   def __init__(
       self,
       session_manager: SessionManager,
       signal_callback: Callable,
       daemon: Optional['SignalDaemon'] = None  # NEW - for approval_workflow access
   ):
   ```

4. Update daemon's start() method to pass self to session_commands:
   ```python
   session_commands = SessionCommands(
       session_manager=self.session_manager,
       signal_callback=self._send_message,
       daemon=self  # NEW
   )
   ```

This gives orchestrator access to approval workflow for operation interception.
  </action>
  <verify>Orchestrator receives approval_workflow, interception works</verify>
  <done>ApprovalWorkflow wired into ClaudeOrchestrator instances</done>
</task>

<task type="auto">
  <name>Task 4: Add approval system startup logging</name>
  <files>src/daemon/service.py, tests/test_daemon.py</files>
  <action>
Add startup logging for approval system (follow Phase 4-5 pattern):

1. In start() method, after thread mapper logging:
   ```python
   logger.info(
       "approval_system_initialized",
       detector_rules=len(self.approval_detector.RULES),  # Or similar metric
       pending_approvals=len(self.approval_manager.get_pending())
   )
   ```

2. Add test in tests/test_daemon.py:
   ```python
   def test_daemon_startup_initializes_approval_system(capsys, mock_health_server):
       """Verify daemon initializes approval system on startup."""
       daemon = SignalDaemon(...)
       await daemon.start()

       # Verify approval components exist
       assert daemon.approval_detector is not None
       assert daemon.approval_manager is not None
       assert daemon.approval_workflow is not None

       # Verify startup logging
       captured = capsys.readouterr()
       assert "approval_system_initialized" in captured.out
   ```

Follow Phase 4-5 pattern: use capsys fixture for structlog output verification.
  </action>
  <verify>Startup logs show approval system initialized, test passes</verify>
  <done>Approval system startup logged and tested</done>
</task>

</tasks>

<verification>
- [ ] Daemon initializes approval system without errors
- [ ] ApprovalCommands routes through SessionCommands
- [ ] ClaudeOrchestrator receives approval_workflow
- [ ] Startup logging shows approval system initialized
- [ ] All tests pass (daemon, approval integration)
</verification>

<success_criteria>
- Approval system initialized in daemon __init__
- ApprovalCommands wired into command routing hierarchy
- ApprovalWorkflow passed to all ClaudeOrchestrator instances
- Startup logging confirms approval system ready
- Tests verify integration works correctly
- End-to-end: User can trigger approval flow from Signal
</success_criteria>

<output>
After completion, create `.planning/phases/05-permissions/05-05-SUMMARY.md`
</output>
