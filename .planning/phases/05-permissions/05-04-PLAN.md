---
phase: 05-permissions
plan: 04
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - src/approval/commands.py
  - src/session/commands.py
  - tests/test_approval_commands.py
autonomous: true

must_haves:
  truths:
    - "User can approve operation with 'approve {id}' command"
    - "User can reject operation with 'reject {id}' command"
    - "User can approve all pending with 'approve all' command"
    - "User receives confirmation message after approval/rejection"
  artifacts:
    - path: "src/approval/commands.py"
      provides: "Approval command handlers"
      exports: ["ApprovalCommands"]
    - path: "tests/test_approval_commands.py"
      provides: "Tests for approval commands"
      min_lines: 50
  key_links:
    - from: "ApprovalCommands.handle()"
      to: "ApprovalManager.approve()"
      via: "Routes 'approve {id}' to manager"
      pattern: "manager\\.approve"
    - from: "SessionCommands.handle()"
      to: "ApprovalCommands.handle()"
      via: "Routes approval commands to approval handler"
      pattern: "approval_commands\\.handle"
---

<objective>
Implement approval command interface for user approval/rejection from Signal.

Purpose: Enable users to approve/reject operations via Signal messages
Output: ApprovalCommands with /approve and /reject command handlers
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 5 dependencies
@.planning/phases/05-permissions/05-01-SUMMARY.md
@.planning/phases/05-permissions/05-02-SUMMARY.md

# Phase 2 command patterns
@.planning/phases/02-session-management/02-05-SUMMARY.md
@src/session/commands.py

# Current approval components
@src/approval/manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ApprovalCommands handler</name>
  <files>src/approval/commands.py, tests/test_approval_commands.py</files>
  <action>
Create ApprovalCommands following SessionCommands pattern from Phase 2-5:

1. __init__ takes ApprovalManager
2. handle(message: str) → Optional[str]:
   - Parse "approve {id}" → manager.approve(id), return "✅ Approved {id[:8]}"
   - Parse "reject {id}" → manager.reject(id), return "❌ Rejected {id[:8]}"
   - Parse "approve all" → manager.approve_all(), return "✅ Approved all pending ({count})"
   - Unknown command → return None (let SessionCommands handle)
3. help() → str with command reference:
   - "Approval Commands:"
   - "  approve {id} - Approve pending operation"
   - "  reject {id} - Reject pending operation"
   - "  approve all - Approve all pending operations"

Follow Phase 4-2 pattern: truncate IDs to 8 chars for mobile-friendly display.

Write tests covering all command variants, edge cases (invalid ID, already approved).
  </action>
  <verify>pytest tests/test_approval_commands.py passes</verify>
  <done>ApprovalCommands handles approve/reject/approve-all commands</done>
</task>

<task type="auto">
  <name>Task 2: Wire ApprovalCommands into SessionCommands</name>
  <files>src/session/commands.py</files>
  <action>
Integrate ApprovalCommands into SessionCommands routing (follow Phase 4-3 ThreadCommands pattern):

1. Add approval_commands: Optional[ApprovalCommands] to __init__ (optional for backwards compat)
2. In handle() method, check approval commands BEFORE session commands:
   ```python
   if self.approval_commands:
       result = self.approval_commands.handle(message)
       if result is not None:
           return result
   ```
3. Add approval commands to help() output (after thread commands, before session commands)

This enables routing: message → SessionCommands → ApprovalCommands → ApprovalManager.

Approval commands take priority over session commands (user approving is more urgent).
  </action>
  <verify>Approval commands route correctly through SessionCommands</verify>
  <done>ApprovalCommands wired into command hierarchy</done>
</task>

<task type="auto">
  <name>Task 3: Implement ApprovalManager.approve_all()</name>
  <files>src/approval/manager.py, tests/test_approval_manager.py</files>
  <action>
Add batch approval support to ApprovalManager (from ROADMAP PERM-07 requirement):

1. Add approve_all() → int method:
   - Find all requests with state=PENDING
   - Call approve(id) for each
   - Return count of approved requests
2. Add get_pending() → List[ApprovalRequest]:
   - Return list of pending requests for display
   - Used by workflow to show "X pending approvals" message

Add tests for approve_all():
- Empty pending list → returns 0
- Multiple pending → approves all, returns count
- Mixed states → only approves PENDING, skips others

Follow TDD: write failing tests, implement to pass.
  </action>
  <verify>pytest tests/test_approval_manager.py passes (approve_all tests)</verify>
  <done>ApprovalManager supports batch approval via approve_all()</done>
</task>

</tasks>

<verification>
- [ ] ApprovalCommands tests pass
- [ ] Command routing works through SessionCommands
- [ ] approve_all() tests pass
- [ ] All edge cases covered (invalid ID, already approved, empty pending)
</verification>

<success_criteria>
- ApprovalCommands handles approve/reject/approve-all
- Commands route correctly through SessionCommands hierarchy
- approve_all() approves multiple pending operations
- Tests cover all command variants and edge cases
- Mobile-friendly ID display (8 chars)
</success_criteria>

<output>
After completion, create `.planning/phases/05-permissions/05-04-SUMMARY.md`
</output>
