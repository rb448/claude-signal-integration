---
phase: 05-permissions
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - src/approval/workflow.py
  - src/claude/orchestrator.py
  - tests/test_approval_workflow.py
autonomous: false

must_haves:
  truths:
    - "Destructive operations pause execution and send approval request to Signal"
    - "User receives formatted approval message with operation details"
    - "System resumes after approval, skips after rejection"
  artifacts:
    - path: "src/approval/workflow.py"
      provides: "Approval workflow coordination"
      exports: ["ApprovalWorkflow"]
    - path: "tests/test_approval_workflow.py"
      provides: "Integration tests for approval flow"
      min_lines: 60
  key_links:
    - from: "ApprovalWorkflow.intercept()"
      to: "OperationDetector.classify()"
      via: "Checks if operation is destructive"
      pattern: "detector\\.classify"
    - from: "ApprovalWorkflow.intercept()"
      to: "ApprovalManager.request()"
      via: "Creates approval request for destructive operations"
      pattern: "manager\\.request"
    - from: "ClaudeOrchestrator"
      to: "ApprovalWorkflow.intercept()"
      via: "Checks approval before executing tool"
      pattern: "workflow\\.intercept"
---

<objective>
Integrate approval workflow into Claude orchestrator with user verification checkpoint.

Purpose: Wire operation detection and approval state machine into live Claude execution
Output: End-to-end approval workflow with Signal notification
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 5 dependencies
@.planning/phases/05-permissions/05-01-SUMMARY.md
@.planning/phases/05-permissions/05-02-SUMMARY.md

# Phase 3 orchestrator
@.planning/phases/03-claude-integration/03-04-SUMMARY.md
@src/claude/orchestrator.py

# Current approval components
@src/approval/detector.py
@src/approval/manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ApprovalWorkflow coordinator</name>
  <files>src/approval/workflow.py, tests/test_approval_workflow.py</files>
  <action>
Create ApprovalWorkflow class that coordinates detector and manager:

1. __init__ takes OperationDetector and ApprovalManager
2. intercept(tool_call) method:
   - Classify operation via detector
   - If SAFE: return (approved=True, request_id=None)
   - If DESTRUCTIVE: create approval request via manager, return (approved=False, request_id=id)
3. wait_for_approval(request_id, timeout=600) async method:
   - Poll approval state every 1 second
   - Return True if approved, False if rejected/timeout
4. format_approval_message(tool_call, reason) → user-friendly text:
   - "⚠️ Approval needed: {tool} on {target}"
   - "Reason: {reason}"
   - "Reply 'approve {request_id}' or 'reject {request_id}'"

Write tests FIRST (TDD for business logic), then implement.
  </action>
  <verify>pytest tests/test_approval_workflow.py passes</verify>
  <done>ApprovalWorkflow coordinates detector and manager, tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Wire approval workflow into ClaudeOrchestrator</name>
  <files>src/claude/orchestrator.py</files>
  <action>
Integrate approval workflow into orchestrator's stream_response() method:

1. Add approval_workflow: Optional[ApprovalWorkflow] parameter to __init__
2. In stream_response(), before executing tool call:
   - Call workflow.intercept(parsed) when OutputType.TOOL_CALL
   - If approved=False:
     - Send approval message to Signal via callback
     - Call workflow.wait_for_approval(request_id)
     - If wait returns False: skip tool execution, log rejection
     - If wait returns True: proceed with tool execution
3. Add approve_operation(request_id) method:
   - Delegates to workflow.manager.approve(request_id)
4. Add reject_operation(request_id) method:
   - Delegates to workflow.manager.reject(request_id)

Follow Phase 3-4 pattern for optional component wiring (backwards compatibility).
  </action>
  <verify>Orchestrator pauses for approval, resumes after user response</verify>
  <done>Approval workflow integrated, orchestrator pauses for destructive operations</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Approval workflow integrated with Claude orchestrator - destructive operations now pause for approval</what-built>
  <how-to-verify>
Test the approval flow manually:

1. Start daemon: `python -m src.daemon.service`
2. From Signal, send: `/session start /path/to/test/project`
3. Send Claude command that triggers Edit: "Edit the README to add a greeting"
4. Verify: You receive approval request message in Signal with request ID
5. Verify: Message format shows tool, target, reason, and approval instructions
6. Reply: `approve {request_id}` (use actual ID from message)
7. Verify: Claude proceeds with edit operation
8. Verify: Edit completes successfully

Test rejection flow:
9. Trigger another Edit command
10. Reply: `reject {request_id}`
11. Verify: Claude skips the operation with rejection message
  </how-to-verify>
  <resume-signal>Type "approved" if approval flow works correctly, or describe issues</resume-signal>
</task>

</tasks>

<verification>
- [ ] ApprovalWorkflow tests pass
- [ ] Orchestrator integration complete
- [ ] Manual approval flow tested end-to-end
- [ ] Rejection flow tested
- [ ] Safe operations (Read/Grep) don't trigger approvals
</verification>

<success_criteria>
- ApprovalWorkflow coordinates detector and manager
- ClaudeOrchestrator pauses for destructive operations
- User receives formatted approval requests
- Approve/reject commands work correctly
- Safe operations bypass approval workflow
- Human verification confirms end-to-end flow
</success_criteria>

<output>
After completion, create `.planning/phases/05-permissions/05-03-SUMMARY.md`
</output>
