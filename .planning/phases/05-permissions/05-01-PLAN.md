---
phase: 05-permissions
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/approval/__init__.py
  - src/approval/detector.py
  - tests/test_approval_detector.py
autonomous: true

must_haves:
  truths:
    - "System classifies Read/Grep as safe operations"
    - "System classifies Edit/Write/Bash as destructive operations"
    - "System provides clear reason for destructive classification"
  artifacts:
    - path: "src/approval/detector.py"
      provides: "Operation classification logic"
      exports: ["OperationDetector", "OperationType"]
    - path: "tests/test_approval_detector.py"
      provides: "TDD test suite for operation detection"
      min_lines: 50
  key_links:
    - from: "OperationDetector.classify()"
      to: "ToolCall object"
      via: "Analyzes tool name and target"
      pattern: "tool_call\\.tool"
---

<objective>
Implement TDD-driven operation detector that classifies Claude tool calls as safe or destructive.

Purpose: Foundation for approval workflow - must reliably detect operations requiring user approval
Output: OperationDetector with comprehensive test coverage following RED-GREEN-REFACTOR cycle
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 3 context - tool call structure
@.planning/phases/03-claude-integration/03-02-SUMMARY.md
@src/claude/parser.py
</context>

<feature>
  <name>Operation Detection and Classification</name>
  <files>src/approval/detector.py, tests/test_approval_detector.py</files>
  <behavior>
**Classification rules (from ROADMAP TDD Strategy):**

Safe operations (no approval needed):
- Read: Reading files is always safe
- Grep: Searching content is safe
- Glob: Listing files is safe

Destructive operations (require approval):
- Edit: Modifying existing files
- Write: Creating new files or overwriting
- Bash: Shell commands (can delete, push, etc.)

**Expected behavior:**
```python
# Input: ToolCall(tool="Read", target="file.py")
# Output: (OperationType.SAFE, "Read operations don't modify state")

# Input: ToolCall(tool="Edit", target="file.py")
# Output: (OperationType.DESTRUCTIVE, "Edit modifies existing file")

# Input: ToolCall(tool="Bash", command="git push")
# Output: (OperationType.DESTRUCTIVE, "Shell command can modify remote state")
```

**Edge cases:**
- Bash with read-only commands (ls, cat) still marked destructive (conservative approach)
- Missing tool or target handled gracefully
- Unknown tool types default to destructive (fail-safe)
  </behavior>
  <implementation>
**After tests written and failing:**

1. Create OperationType enum (SAFE, DESTRUCTIVE)
2. Create OperationDetector class
3. Implement classify() method with rule-based logic
4. Map each tool to its classification
5. Provide descriptive reason strings
6. Handle edge cases (unknown tools, missing data)
  </implementation>
</feature>

<verification>
- [ ] pytest tests/test_approval_detector.py passes
- [ ] All tool types have test coverage
- [ ] Edge cases tested (unknown tools, missing data)
- [ ] RED-GREEN-REFACTOR cycle followed (3 commits)
</verification>

<success_criteria>
- Failing test written and committed (RED phase)
- Implementation passes all tests (GREEN phase)
- Code refactored if needed (REFACTOR phase)
- All 2-3 commits present with correct format
- Read/Grep classified as SAFE
- Edit/Write/Bash classified as DESTRUCTIVE
- Unknown tools default to DESTRUCTIVE
</success_criteria>

<output>
After completion, create `.planning/phases/05-permissions/05-01-SUMMARY.md`

Include:
- RED: What tests were written, why they failed
- GREEN: Implementation that made tests pass
- REFACTOR: Any cleanup done (if applicable)
- Commits: List of all commits (test → feat → refactor if done)
</output>
