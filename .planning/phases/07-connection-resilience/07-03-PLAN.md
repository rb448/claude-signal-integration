---
phase: 07-connection-resilience
plan: 03
type: execute
wave: 2
depends_on: ["07-01", "07-02"]
files_modified:
  - src/signal/client.py
  - src/daemon/service.py
  - tests/test_signal_client.py
autonomous: true

must_haves:
  truths:
    - "WebSocket reconnects automatically after network drop"
    - "Outgoing messages buffer during disconnect and send on reconnect"
    - "User sees connection status updates"
  artifacts:
    - path: "src/signal/client.py"
      provides: "Integrated reconnection logic in SignalClient"
      min_lines: 200
    - path: "src/daemon/service.py"
      provides: "Connection status logging"
  key_links:
    - from: "SignalClient.receive_messages()"
      to: "ReconnectionManager"
      via: "handle connection failures"
      pattern: "reconnection_manager"
    - from: "SignalClient.send_message()"
      to: "MessageBuffer"
      via: "buffer when disconnected"
      pattern: "message_buffer"
---

<objective>
Integrate ReconnectionManager and MessageBuffer into SignalClient for automatic reconnection.

Purpose: Make Signal connection resilient to network drops with automatic reconnection and message buffering.

Output: SignalClient that automatically reconnects on failures and buffers messages during disconnects.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-connection-resilience/07-01-SUMMARY.md
@.planning/phases/07-connection-resilience/07-02-SUMMARY.md

# Components to integrate
@src/signal/reconnection.py
@src/signal/message_buffer.py

# Target integration points
@src/signal/client.py
@src/daemon/service.py

Phase 7 Requirements:
- CONN-01: Automatic reconnection with exponential backoff
- CONN-02: Message buffering during disconnect
- CONN-04: Connection status indicators
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ReconnectionManager and MessageBuffer to SignalClient</name>
  <files>src/signal/client.py</files>
  <action>
    Modify SignalClient class:

    1. Import dependencies:
       ```python
       from .reconnection import ReconnectionManager, ConnectionState
       from .message_buffer import MessageBuffer
       ```

    2. Add to __init__:
       ```python
       self.reconnection_manager = ReconnectionManager()
       self.message_buffer = MessageBuffer(max_size=100)
       self._reconnect_task: Optional[asyncio.Task] = None
       ```

    3. Update connect() method:
       - On successful connect: self.reconnection_manager.transition(ConnectionState.CONNECTED)
       - On failure: self.reconnection_manager.transition(ConnectionState.DISCONNECTED)

    4. Add auto_reconnect() method:
       ```python
       async def auto_reconnect(self) -> None:
           \"\"\"Automatically reconnect with exponential backoff.\"\"\"
           while self.reconnection_manager.state == ConnectionState.DISCONNECTED:
               # Transition to RECONNECTING
               self.reconnection_manager.transition(ConnectionState.RECONNECTING)

               # Calculate backoff delay
               delay = self.reconnection_manager.calculate_backoff()
               logger.info(
                   "reconnecting",
                   attempt=self.reconnection_manager.attempt_count,
                   delay_seconds=delay
               )
               await asyncio.sleep(delay)

               # Attempt reconnection
               try:
                   await self.connect()
                   # Success - drain buffered messages
                   await self._drain_buffer()
                   break
               except ConnectionError:
                   # Failed - will retry
                   self.reconnection_manager.transition(ConnectionState.DISCONNECTED)
       ```

    5. Add _drain_buffer() method:
       ```python
       async def _drain_buffer(self) -> None:
           \"\"\"Send all buffered messages after reconnection.\"\"\"
           messages = self.message_buffer.drain()
           logger.info("draining_message_buffer", count=len(messages))

           for recipient, text in messages:
               try:
                   await self.send_message(recipient, text)
               except Exception as e:
                   logger.error("failed_to_send_buffered_message", error=str(e))
       ```

    6. Modify send_message():
       - If disconnected: buffer instead of sending
       - If connected: send normally
       ```python
       if self.reconnection_manager.state != ConnectionState.CONNECTED:
           self.message_buffer.enqueue(recipient, text)
           logger.info("message_buffered", recipient=recipient)
           return
       # ... existing send logic
       ```

    7. Modify receive_messages():
       - Catch connection errors
       - Trigger auto_reconnect() on failure
       ```python
       except aiohttp.ClientError as e:
           logger.error("connection_lost", error=str(e))
           self.reconnection_manager.transition(ConnectionState.DISCONNECTED)
           self._reconnect_task = asyncio.create_task(self.auto_reconnect())
           # Stop iteration - will resume after reconnect
           return
       ```
  </action>
  <verify>
    - mypy src/signal/client.py passes (type safety)
    - SignalClient imports ReconnectionManager and MessageBuffer successfully
    - send_message() checks connection state before sending
  </verify>
  <done>
    - ReconnectionManager integrated into SignalClient lifecycle
    - MessageBuffer integrated into send_message()
    - auto_reconnect() method implements exponential backoff loop
    - Connection failures trigger reconnection automatically
  </done>
</task>

<task type="auto">
  <name>Task 2: Add connection status logging to daemon</name>
  <files>src/daemon/service.py</files>
  <action>
    Update daemon startup logging to show connection resilience enabled:

    In run() method after Signal client connects:
    ```python
    logger.info(
        "daemon_started",
        phone_number=self.auth.authorized_number,
        health_port=8081,
        connection_resilience="enabled",
        reconnection_backoff="exponential_1s_to_60s",
        message_buffer_size=100
    )
    ```

    Add handler for reconnection events (subscribe to client state changes):
    - When client.reconnection_manager.state changes
    - Log: "connection_status_changed", old_state, new_state
    - If RECONNECTING: log attempt count and delay
  </action>
  <verify>Daemon logs show connection_resilience enabled on startup</verify>
  <done>
    - Daemon startup logs connection resilience configuration
    - State changes logged for debugging
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for reconnection integration</name>
  <files>tests/test_signal_client.py</files>
  <action>
    Add integration tests to existing test_signal_client.py:

    Test 1: test_auto_reconnect_after_connection_failure
    - Mock connect() to fail 2 times, succeed on 3rd
    - Call auto_reconnect()
    - Assert attempt_count incremented correctly
    - Assert backoff delays: 1s, 2s (mocked)
    - Assert final state is CONNECTED

    Test 2: test_send_message_buffers_when_disconnected
    - Set state to DISCONNECTED
    - Call send_message("+1234", "test")
    - Assert message buffered (not sent)
    - Assert buffer has 1 message

    Test 3: test_drain_buffer_sends_all_messages_after_reconnect
    - Buffer 3 messages while disconnected
    - Reconnect
    - Call _drain_buffer()
    - Assert all 3 messages sent via send_message()
    - Assert buffer empty

    Mock aiohttp session and asyncio.sleep for deterministic testing
  </action>
  <verify>pytest tests/test_signal_client.py::test_auto_reconnect_after_connection_failure -v passes</verify>
  <done>
    - Integration tests verify reconnection logic
    - Buffering behavior tested
    - Drain logic tested
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] pytest tests/test_signal_client.py passes (all existing + new tests)
- [ ] mypy src/signal/client.py passes
- [ ] SignalClient.send_message() buffers when disconnected
- [ ] SignalClient.auto_reconnect() implements exponential backoff
- [ ] Daemon logs connection resilience configuration
- [ ] No test skips introduced
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- SignalClient automatically reconnects after failures
- Messages buffered during disconnects and sent on reconnect
- Connection status changes logged for visibility
</success_criteria>

<output>
After completion, create `.planning/phases/07-connection-resilience/07-03-SUMMARY.md`
</output>
