---
phase: 07-connection-resilience
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/signal/message_buffer.py
  - tests/test_message_buffer.py
autonomous: true

must_haves:
  truths:
    - "Outgoing messages buffer during disconnect and send on reconnect"
    - "Buffer preserves message order (FIFO)"
    - "Buffer prevents memory exhaustion with size limits"
  artifacts:
    - path: "src/signal/message_buffer.py"
      provides: "Message buffer with drain-on-reconnect logic"
      min_lines: 80
      exports: ["MessageBuffer"]
  key_links:
    - from: "MessageBuffer.enqueue()"
      to: "deque collection"
      via: "append to buffer during disconnect"
      pattern: "deque.*append"
---

<objective>
Implement message buffer for queueing outgoing messages during disconnects.

Purpose: Preserve messages sent while mobile is offline, deliver them when connection restored.

Output: MessageBuffer that queues messages during disconnect and drains on reconnect.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-connection-resilience/07-01-SUMMARY.md

Phase 7 Requirements:
- CONN-02: System buffers outgoing messages during disconnect and sends on reconnect
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD - Write failing tests for MessageBuffer FIFO behavior</name>
  <files>tests/test_message_buffer.py</files>
  <action>
    Create tests/test_message_buffer.py (RED phase):

    Test 1: test_enqueue_and_dequeue_fifo_order
    - Enqueue 3 messages: "msg1", "msg2", "msg3"
    - Dequeue all
    - Assert order preserved (msg1, msg2, msg3)

    Test 2: test_enqueue_when_full_drops_oldest
    - Create buffer with max_size=3
    - Enqueue 4 messages
    - Verify oldest (msg1) dropped, buffer has [msg2, msg3, msg4]

    Test 3: test_drain_returns_all_buffered_messages
    - Enqueue 5 messages
    - Call drain()
    - Assert returns all 5 messages in order
    - Assert buffer now empty

    Expected: Tests FAIL (MessageBuffer doesn't exist)
  </action>
  <verify>pytest tests/test_message_buffer.py -v shows 3 failures</verify>
  <done>Buffer tests written and failing (RED phase)</done>
</task>

<task type="auto">
  <name>Task 2: TDD - Implement MessageBuffer with FIFO and size limits (GREEN phase)</name>
  <files>src/signal/message_buffer.py</files>
  <action>
    Create src/signal/message_buffer.py:

    ```python
    from collections import deque
    from typing import List, Tuple

    class MessageBuffer:
        """Buffer for outgoing messages during disconnect.

        Uses FIFO (deque) with size limit to prevent memory exhaustion.
        Oldest messages dropped if buffer full.
        """

        def __init__(self, max_size: int = 100):
            """
            Initialize message buffer.

            Args:
                max_size: Maximum messages to buffer (default 100)
            """
            self.max_size = max_size
            self._buffer: deque = deque(maxlen=max_size)

        def enqueue(self, recipient: str, text: str) -> None:
            """
            Add message to buffer.

            If buffer full, oldest message automatically dropped (deque behavior).

            Args:
                recipient: Phone number in E.164 format
                text: Message text
            """
            self._buffer.append((recipient, text))

        def dequeue(self) -> Tuple[str, str] | None:
            """
            Remove and return oldest message from buffer.

            Returns:
                (recipient, text) tuple or None if buffer empty
            """
            if self._buffer:
                return self._buffer.popleft()
            return None

        def drain(self) -> List[Tuple[str, str]]:
            """
            Remove and return all buffered messages.

            Returns:
                List of (recipient, text) tuples in FIFO order
            """
            messages = list(self._buffer)
            self._buffer.clear()
            return messages

        def __len__(self) -> int:
            """Return number of buffered messages."""
            return len(self._buffer)

        def is_empty(self) -> bool:
            """Check if buffer is empty."""
            return len(self._buffer) == 0
    ```

    Run tests - should now PASS (GREEN phase)
  </action>
  <verify>pytest tests/test_message_buffer.py -v shows 3 passes</verify>
  <done>MessageBuffer implemented with FIFO and size limits</done>
</task>

<task type="auto">
  <name>Task 3: TDD - Write failing tests for buffer state queries</name>
  <files>tests/test_message_buffer.py</files>
  <action>
    Add state query tests (RED phase):

    Test 4: test_is_empty_returns_correct_state
    - New buffer: is_empty() == True
    - After enqueue: is_empty() == False
    - After drain: is_empty() == True

    Test 5: test_len_returns_buffer_count
    - New buffer: len(buffer) == 0
    - After 3 enqueues: len(buffer) == 3
    - After 1 dequeue: len(buffer) == 2
    - After drain: len(buffer) == 0

    Expected: Tests PASS (methods already implemented)
  </action>
  <verify>pytest tests/test_message_buffer.py::test_is_empty_returns_correct_state -v passes</verify>
  <done>State query tests written and passing</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All TDD tests pass (5 tests minimum)
- [ ] FIFO ordering verified via tests
- [ ] Size limit enforcement verified
- [ ] Buffer can be drained and cleared
- [ ] No test skips introduced
</verification>

<success_criteria>
- All tasks completed following TDD discipline
- All verification checks pass
- MessageBuffer ready for integration with reconnection logic
- Tests demonstrate FIFO, size limits, and drain behavior
</success_criteria>

<output>
After completion, create `.planning/phases/07-connection-resilience/07-02-SUMMARY.md`
</output>
