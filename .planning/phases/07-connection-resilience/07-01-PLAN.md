---
phase: 07-connection-resilience
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/signal/reconnection.py
  - tests/test_reconnection.py
autonomous: true

must_haves:
  truths:
    - "WebSocket reconnects automatically after network drop"
    - "Exponential backoff prevents reconnection storms"
    - "Connection state transitions tracked correctly"
  artifacts:
    - path: "src/signal/reconnection.py"
      provides: "Reconnection state machine with exponential backoff"
      min_lines: 100
      exports: ["ReconnectionManager", "ConnectionState"]
  key_links:
    - from: "ReconnectionManager.on_disconnect()"
      to: "backoff calculator"
      via: "exponential backoff algorithm"
      pattern: "attempt.*\\*\\*.*2"
---

<objective>
Implement reconnection state machine with exponential backoff for Signal API connection resilience.

Purpose: Enable automatic reconnection after network drops, preventing connection storms with exponential backoff (1s, 2s, 4s, 8s, up to 60s max).

Output: ReconnectionManager that tracks connection state and calculates appropriate backoff delays.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Current Signal client implementation
@src/signal/client.py
@src/daemon/service.py

# Requirements for this phase
Phase 7 Requirements:
- CONN-01: System automatically reconnects WebSocket after network drop with exponential backoff
- CONN-02: System buffers outgoing messages during disconnect and sends on reconnect
- CONN-03: System synchronizes session state after reconnection
- CONN-04: System displays connection status indicators (connected/reconnecting/offline/syncing)
- CONN-05: Claude continues working during mobile disconnect, user catches up on reconnect
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD - Write failing tests for ConnectionState enum and state transitions</name>
  <files>tests/test_reconnection.py</files>
  <action>
    Create test file tests/test_reconnection.py with TDD approach (RED phase):

    Test 1: test_connection_state_enum
    - Assert ConnectionState has values: CONNECTED, DISCONNECTED, RECONNECTING, SYNCING
    - Verify enum values are distinct

    Test 2: test_valid_state_transitions
    - CONNECTED → DISCONNECTED (network drop)
    - DISCONNECTED → RECONNECTING (start reconnect attempt)
    - RECONNECTING → CONNECTED (successful reconnect)
    - RECONNECTING → DISCONNECTED (failed attempt, will retry)
    - CONNECTED → SYNCING (reconnected, syncing state)
    - SYNCING → CONNECTED (sync complete)

    Test 3: test_invalid_state_transitions
    - DISCONNECTED → SYNCING (can't sync while disconnected)
    - RECONNECTING → SYNCING (must connect first)

    Expected: All tests FAIL (ConnectionState and validation don't exist yet)
  </action>
  <verify>pytest tests/test_reconnection.py -v shows 3 failures (ImportError or AttributeError)</verify>
  <done>Tests written, running, and failing as expected (RED phase complete)</done>
</task>

<task type="auto">
  <name>Task 2: TDD - Implement ConnectionState and basic state machine (GREEN phase)</name>
  <files>src/signal/reconnection.py</files>
  <action>
    Create src/signal/reconnection.py to pass tests:

    1. Define ConnectionState enum:
       ```python
       from enum import Enum, auto

       class ConnectionState(Enum):
           CONNECTED = auto()
           DISCONNECTED = auto()
           RECONNECTING = auto()
           SYNCING = auto()
       ```

    2. Create ReconnectionManager class:
       ```python
       class ReconnectionManager:
           # Valid state transitions (set of tuples)
           VALID_TRANSITIONS = {
               (ConnectionState.CONNECTED, ConnectionState.DISCONNECTED),
               (ConnectionState.DISCONNECTED, ConnectionState.RECONNECTING),
               (ConnectionState.RECONNECTING, ConnectionState.CONNECTED),
               (ConnectionState.RECONNECTING, ConnectionState.DISCONNECTED),
               (ConnectionState.CONNECTED, ConnectionState.SYNCING),
               (ConnectionState.SYNCING, ConnectionState.CONNECTED),
           }

           def __init__(self):
               self.state = ConnectionState.CONNECTED
               self.attempt_count = 0

           def transition(self, new_state: ConnectionState) -> bool:
               if (self.state, new_state) in self.VALID_TRANSITIONS:
                   self.state = new_state
                   if new_state == ConnectionState.RECONNECTING:
                       self.attempt_count += 1
                   elif new_state == ConnectionState.CONNECTED:
                       self.attempt_count = 0  # Reset on success
                   return True
               return False
       ```

    Run tests - should now PASS (GREEN phase)
  </action>
  <verify>pytest tests/test_reconnection.py -v shows 3 passes</verify>
  <done>ConnectionState enum and state machine implemented, all tests passing</done>
</task>

<task type="auto">
  <name>Task 3: TDD - Write failing tests for exponential backoff calculator</name>
  <files>tests/test_reconnection.py</files>
  <action>
    Add backoff tests to tests/test_reconnection.py (RED phase):

    Test 4: test_exponential_backoff_calculation
    - Attempt 1: 1 second
    - Attempt 2: 2 seconds
    - Attempt 3: 4 seconds
    - Attempt 4: 8 seconds
    - Attempt 5: 16 seconds
    - Attempt 6: 32 seconds
    - Attempt 7: 60 seconds (capped at max)
    - Attempt 8: 60 seconds (still capped)

    Test 5: test_backoff_resets_on_successful_connection
    - Set attempt_count = 5
    - Transition to CONNECTED
    - Verify next backoff returns 1 second (reset)

    Expected: Tests FAIL (calculate_backoff() method doesn't exist)
  </action>
  <verify>pytest tests/test_reconnection.py::test_exponential_backoff_calculation -v fails</verify>
  <done>Backoff tests written and failing (RED phase)</done>
</task>

<task type="auto">
  <name>Task 4: TDD - Implement exponential backoff calculator (GREEN phase)</name>
  <files>src/signal/reconnection.py</files>
  <action>
    Add calculate_backoff() method to ReconnectionManager:

    ```python
    def calculate_backoff(self) -> float:
        """Calculate exponential backoff delay in seconds.

        Formula: min(2^(attempt_count - 1), MAX_BACKOFF)
        - Attempt 1: 1s
        - Attempt 2: 2s
        - Attempt 3: 4s
        - Attempt 4: 8s
        - Attempt 5: 16s
        - Attempt 6: 32s
        - Attempt 7+: 60s (max)

        Returns:
            Backoff delay in seconds
        """
        MAX_BACKOFF = 60.0
        if self.attempt_count == 0:
            return 1.0  # First attempt (after reset)

        # 2^(attempt - 1) with cap at MAX_BACKOFF
        delay = 2 ** (self.attempt_count - 1)
        return min(delay, MAX_BACKOFF)
    ```

    Run tests - should now PASS (GREEN phase)
  </action>
  <verify>pytest tests/test_reconnection.py -v shows all 5 tests passing</verify>
  <done>Exponential backoff calculator implemented, tests passing</done>
</task>

<task type="auto">
  <name>Task 5: TDD - Write failing tests for reconnection workflow</name>
  <files>tests/test_reconnection.py</files>
  <action>
    Add integration tests for full reconnection workflow (RED phase):

    Test 6: test_reconnection_workflow_success
    - Start in CONNECTED state
    - Simulate disconnect: transition(DISCONNECTED)
    - Start reconnect: transition(RECONNECTING)
    - Calculate backoff (should be 1s for first attempt)
    - Simulate success: transition(CONNECTED)
    - Verify state is CONNECTED, attempt_count reset to 0

    Test 7: test_reconnection_workflow_multiple_failures
    - Start in CONNECTED, transition to DISCONNECTED
    - Attempt 1: RECONNECTING → backoff 1s → fail → DISCONNECTED
    - Attempt 2: RECONNECTING → backoff 2s → fail → DISCONNECTED
    - Attempt 3: RECONNECTING → backoff 4s → success → CONNECTED
    - Verify backoff values correct, final state CONNECTED

    Expected: Tests PASS (using existing state machine and backoff)
  </action>
  <verify>pytest tests/test_reconnection.py::test_reconnection_workflow_success -v passes</verify>
  <done>Integration workflow tests written and passing</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All TDD tests pass (RED → GREEN cycle complete for each feature)
- [ ] pytest tests/test_reconnection.py shows 7+ tests passing
- [ ] ConnectionState enum has 4 states (CONNECTED, DISCONNECTED, RECONNECTING, SYNCING)
- [ ] State transitions validated via VALID_TRANSITIONS set
- [ ] Exponential backoff capped at 60 seconds
- [ ] No test skips introduced
</verification>

<success_criteria>
- All tasks completed following TDD discipline
- All verification checks pass
- ReconnectionManager ready for integration with SignalClient
- Tests demonstrate correct state transitions and backoff behavior
</success_criteria>

<output>
After completion, create `.planning/phases/07-connection-resilience/07-01-SUMMARY.md`
</output>
