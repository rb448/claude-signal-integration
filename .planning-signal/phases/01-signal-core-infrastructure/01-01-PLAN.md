---
phase: 01-signal-core-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docker-compose.yml
  - .env
  - src/signal/client.py
  - src/signal/__init__.py
  - requirements.txt
  - pyproject.toml
autonomous: true

must_haves:
  truths:
    - signal-cli-rest-api Docker container runs and responds to health checks
    - Python WebSocket client connects to signal-cli-rest-api successfully
    - Bot receives test messages sent to registered phone number
  artifacts:
    - path: docker-compose.yml
      provides: signal-cli-rest-api service configuration
      min_lines: 20
    - path: src/signal/client.py
      provides: WebSocket client for Signal API
      min_lines: 50
      exports: [SignalClient]
    - path: requirements.txt
      provides: Python dependencies
      contains: "websockets"
  key_links:
    - from: src/signal/client.py
      to: signal-cli-rest-api container
      via: WebSocket connection
      pattern: "websockets\\.connect"
    - from: docker-compose.yml
      to: Signal phone number
      via: environment variables
      pattern: "SIGNAL_NUMBER"
---

<objective>
Establish Signal API infrastructure with Docker and create Python WebSocket client for bidirectional messaging.

Purpose: Foundation for all Signal communication - enables receiving messages from mobile and sending responses back.
Output: Working signal-cli-rest-api container and Python client that can send/receive Signal messages.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning-signal/SIGNAL-PROJECT.md
@.planning-signal/SIGNAL-ROADMAP.md
@.planning-signal/research/SIGNAL-STACK.md - Recommended stack: Python 3.11+, signal-cli-rest-api, websockets
@.planning-signal/research/SIGNAL-ARCHITECTURE.md - Standard architecture patterns for Signal bots
@.planning-signal/SIGNAL-REQUIREMENTS.md - INFRA-01, INFRA-02 requirements
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set up signal-cli-rest-api Docker container</name>
  <files>docker-compose.yml, .env</files>
  <action>
    Create docker-compose.yml configuring signal-cli-rest-api:0.96 container with:
    - JSON-RPC mode enabled (MODE=json-rpc)
    - Port 8080 exposed for REST API
    - Volume mount for signal data persistence
    - Environment variables for phone number from .env

    Create .env with placeholders for SIGNAL_NUMBER and other config.

    Use research/STACK.md recommended versions. Do NOT use native mode or DBus mode.
  </action>
  <verify>docker-compose up -d succeeds, docker ps shows container running, curl http://localhost:8080/v1/health returns 200</verify>
  <done>signal-cli-rest-api container running and health check passing</done>
</task>

<task type="auto">
  <name>Task 2: Create Python project structure with dependencies</name>
  <files>pyproject.toml, requirements.txt, src/signal/__init__.py</files>
  <action>
    Create pyproject.toml for Python 3.11+ project with:
    - Project metadata (name: signal-claude-bot)
    - Dependencies: websockets==16.0, aiohttp>=3.9, pydantic>=2.12.5, structlog==25.5.0

    Generate requirements.txt from pyproject.toml.
    Create src/signal/__init__.py with module initialization.

    Follow research/STACK.md recommended versions exactly. Use uv for package management if available, otherwise pip.
  </action>
  <verify>uv pip install -r requirements.txt succeeds, python -c "import websockets; import aiohttp; import pydantic" runs without errors</verify>
  <done>Python project configured with all core dependencies installed</done>
</task>

<task type="auto">
  <name>Task 3: Implement WebSocket client for Signal API</name>
  <files>src/signal/client.py</files>
  <action>
    Create src/signal/client.py with SignalClient class that:
    - Connects to signal-cli-rest-api WebSocket at ws://localhost:8080
    - Implements async connect() and disconnect() methods
    - Implements send_message(recipient, text) method for sending messages
    - Implements receive_messages() async iterator for incoming messages
    - Includes basic error handling and connection state tracking

    Use websockets library with asyncio patterns. Follow architecture from research/ARCHITECTURE.md.
    Keep implementation simple - no reconnection logic yet (that's Phase 7).
  </action>
  <verify>python -c "from src.signal.client import SignalClient" imports successfully, basic type hints validate</verify>
  <done>SignalClient class implemented with send/receive methods</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Docker container runs: docker ps | grep signal-cli-rest-api shows UP status
- [ ] Health check passes: curl http://localhost:8080/v1/health returns {"status":"ok"} or similar
- [ ] Python imports work: from src.signal.client import SignalClient succeeds
- [ ] Dependencies installed: pip list shows websockets, aiohttp, pydantic, structlog
</verification>

<success_criteria>
- signal-cli-rest-api Docker container running with JSON-RPC mode
- Python project structure created with all dependencies
- SignalClient class implemented with basic send/receive methods
- No errors in imports or Docker container logs
- Foundation ready for message queue implementation (Plan 02)
</success_criteria>

<output>
After completion, create `.planning-signal/phases/01-signal-core-infrastructure/01-01-SUMMARY.md`
</output>
